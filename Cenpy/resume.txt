Contenu du fichier './component-tests/src/graphic/shader/PassTests.cpp':
#include <gtest/gtest.h>
#include <graphic/pipeline/Pass.hpp>

#include <graphic/opengl/profile/Pass.hpp>
#include <graphic/opengl/profile/Shader.hpp>
#include <graphic/opengl/validator/Validator.hpp>
#include <graphic/opengl/pipeline/component/attribute/Binder.hpp>
#include <graphic/opengl/pipeline/component/attribute/Setter.hpp>
#include <graphic/opengl/pipeline/component/attribute/Unbinder.hpp>
#include <graphic/opengl/pipeline/component/uniform/Setter.hpp>
#include <graphic/opengl/pipeline/component/shader/Freer.hpp>
#include <graphic/opengl/pipeline/component/shader/Loader.hpp>
#include <graphic/opengl/pipeline/component/shader/Reader.hpp>
#include <graphic/opengl/pipeline/component/pass/ShaderAttacher.hpp>
#include <graphic/opengl/pipeline/component/pass/UniformReader.hpp>
#include <graphic/opengl/pipeline/component/pass/AttributeReader.hpp>
#include <graphic/opengl/pipeline/component/pass/Loader.hpp>
#include <graphic/opengl/pipeline/component/pass/User.hpp>
#include <graphic/opengl/pipeline/component/pass/Freer.hpp>

#include <graphic/Api.hpp>
#include <graphic/opengl/context/PassContext.hpp>
#include <OpenGLComponentTests.hpp>

#include <filesystem>

namespace api = cenpy::graphic::api;
namespace context = cenpy::graphic::context;
namespace pipeline = cenpy::graphic::pipeline;
namespace profile = cenpy::graphic::opengl::profile;

class PassTest : public OpenGLComponentTest
{
protected:
    std::shared_ptr<pipeline::IShader<api::OpenGL>> vertexShader;
    std::shared_ptr<pipeline::IShader<api::OpenGL>> fragmentShader;

    void SetUp() override
    {
        // print current working directory
        std::cout << "Current working directory: " << std::filesystem::current_path() << std::endl;
        OpenGLComponentTest::SetUp();
        vertexShader = std::make_shared<pipeline::Shader<api::OpenGL, profile::Shader::Classic>>("test-datas/shaders/vertex/good/minimal.vert", context::ShaderType::VERTEX);
        fragmentShader = std::make_shared<pipeline::Shader<api::OpenGL, profile::Shader::Classic>>("test-datas/shaders/fragment/good/minimal.frag", context::ShaderType::FRAGMENT);
    }
};

TEST_F(PassTest, PassCreationTest)
{
    ASSERT_NO_THROW((pipeline::Pass<api::OpenGL, profile::Pass::Classic>({vertexShader, fragmentShader})));
}

TEST_F(PassTest, UniformManagementTest)
{
    pipeline::Pass<api::OpenGL, profile::Pass::Classic> pass({vertexShader, fragmentShader});
    pass.load();

    float testValue = 5.0f;

    ASSERT_NO_THROW(pass.withUniform("testUniform", testValue));

    auto uniforms = pass.getUniforms();
    ASSERT_TRUE(uniforms.contains("testUniform"));
    auto uniform = uniforms.at("testUniform");
    ASSERT_NE(uniform, nullptr);
    ASSERT_EQ(uniform->get<float>(), testValue);
}

TEST_F(PassTest, InvalidUniformTest)
{
    pipeline::Pass<api::OpenGL, profile::Pass::Classic> pass({vertexShader, fragmentShader});

    EXPECT_THROW(pass.withUniform("nonExistentUniform", 5), cenpy::common::exception::TraceableException<std::runtime_error>);
}

TEST_F(PassTest, ShaderAttachmentTest)
{
    pipeline::Pass<api::OpenGL, profile::Pass::Classic> pass({vertexShader, fragmentShader});

    // Since on is protected, we assume its correctness through the absence of exceptions during Pass creation
    ASSERT_NO_THROW((pipeline::Pass<api::OpenGL, profile::Pass::Classic>({vertexShader, fragmentShader})));
}

TEST_F(PassTest, UniformReadingTest)
{
    pipeline::Pass<api::OpenGL, profile::Pass::Classic> pass({vertexShader, fragmentShader});
    pass.load();
    const auto &uniforms = pass.getUniforms();
    // Assuming the shaders have at least one uniform
    ASSERT_FALSE(uniforms.empty());
    // Further checks can be added here based on specific uniforms expected in the shaders
    // For example, we could check if the uniform is a int named "testUniform"
    ASSERT_TRUE(uniforms.contains("testUniform"));
    auto uniform = uniforms.at("testUniform");
    ASSERT_NE(uniform, nullptr);
    ASSERT_NE(uniform->getContext(), nullptr);
    ASSERT_EQ(uniform->getContext()->getGLType(), GL_INT);
}

TEST_F(PassTest, AttributeReadingTest)
{
    pipeline::Pass<api::OpenGL, profile::Pass::Classic> pass({vertexShader, fragmentShader});
    pass.load();
    const auto &attributes = pass.getAttributes();
    // Assuming the shaders have at least one attribute
    ASSERT_FALSE(attributes.empty());
    // Further checks can be added here based on specific attributes expected in the shaders
    // For example, we could check if the attribute is a vec3 named "aPos"
    ASSERT_TRUE(attributes.contains("aPos"));
    auto attribute = attributes.at("aPos");
    ASSERT_NE(attribute, nullptr);
    ASSERT_NE(attribute->getContext(), nullptr);
    ASSERT_EQ(attribute->getContext()->getGLType(), GL_FLOAT_VEC3);
}

TEST_F(PassTest, FreeResourcesTest)
{
    // This test assumes that freeing resources does not cause any observable side effects that can be checked.
    // As such, we are limited to testing for the absence of exceptions.
    auto pass = new pipeline::Pass<api::OpenGL, profile::Pass::Classic>({vertexShader, fragmentShader});

    ASSERT_NO_THROW(delete pass);
}

================================================================================
Contenu du fichier './component-tests/src/graphic/shader/ProgramTests.cpp':
#include <memory>
#include <gtest/gtest.h>
#include <graphic/pipeline/Pipeline.hpp>

#include <graphic/opengl/profile/Pass.hpp>
#include <graphic/opengl/profile/Shader.hpp>
#include <graphic/opengl/profile/Pipeline.hpp>
#include <graphic/opengl/validator/Validator.hpp>
#include <graphic/opengl/pipeline/component/attribute/Binder.hpp>
#include <graphic/opengl/pipeline/component/attribute/Setter.hpp>
#include <graphic/opengl/pipeline/component/attribute/Unbinder.hpp>
#include <graphic/opengl/pipeline/component/uniform/Setter.hpp>
#include <graphic/opengl/pipeline/component/shader/Freer.hpp>
#include <graphic/opengl/pipeline/component/shader/Loader.hpp>
#include <graphic/opengl/pipeline/component/shader/Reader.hpp>
#include <graphic/opengl/pipeline/component/pass/ShaderAttacher.hpp>
#include <graphic/opengl/pipeline/component/pass/UniformReader.hpp>
#include <graphic/opengl/pipeline/component/pass/AttributeReader.hpp>
#include <graphic/opengl/pipeline/component/pass/Loader.hpp>
#include <graphic/opengl/pipeline/component/pass/User.hpp>
#include <graphic/opengl/pipeline/component/pass/Freer.hpp>
#include <graphic/opengl/pipeline/component/pipeline/Resetter.hpp>
#include <graphic/opengl/pipeline/component/pipeline/User.hpp>

#include <graphic/Api.hpp>
#include <graphic/opengl/context/PipelineContext.hpp>
#include <graphic/opengl/context/PassContext.hpp>
#include <OpenGLComponentTests.hpp>

namespace api = cenpy::graphic::api;
namespace context = cenpy::graphic::context;
namespace pipeline = cenpy::graphic::pipeline;
namespace profile = cenpy::graphic::opengl::profile;

class PipelineTest : public OpenGLComponentTest
{
protected:
    std::shared_ptr<pipeline::IPass<api::OpenGL>> pass1;
    std::shared_ptr<pipeline::IPass<api::OpenGL>> pass2;

    void SetUp() override
    {
        OpenGLComponentTest::SetUp();
        // Initialize Passes with valid shaders
        auto vertexShader = std::make_shared<pipeline::Shader<api::OpenGL, profile::Shader::Classic>>("test-datas/shaders/vertex/good/minimal.vert", context::ShaderType::VERTEX);
        auto fragmentShader = std::make_shared<pipeline::Shader<api::OpenGL, profile::Shader::Classic>>("test-datas/shaders/fragment/good/minimal.frag", context::ShaderType::FRAGMENT);
        pass1 = std::shared_ptr<pipeline::Pass<api::OpenGL, profile::Pass::Classic>>(new pipeline::Pass<api::OpenGL, profile::Pass::Classic>({vertexShader, fragmentShader}));
        pass2 = std::shared_ptr<pipeline::Pass<api::OpenGL, profile::Pass::Classic>>(new pipeline::Pass<api::OpenGL, profile::Pass::Classic>({vertexShader, fragmentShader}));
    }
};

TEST_F(PipelineTest, PipelineCreationTest)
{
    ASSERT_NO_THROW((pipeline::Pipeline<api::OpenGL, profile::Pipeline::Classic>({pass1, pass2})));
}

TEST_F(PipelineTest, UsePassTest)
{
    pipeline::Pipeline<api::OpenGL, profile::Pipeline::Classic> pipeline({pass1, pass2});

    // Test using the first pass
    ASSERT_NO_THROW(pipeline.use(0));
    // Add checks if there are specific observable effects of using a pass

    // Test using the second pass
    ASSERT_NO_THROW(pipeline.use(1));
    // Add checks for the second pass
}

TEST_F(PipelineTest, UseNextPassTest)
{
    pipeline::Pipeline<api::OpenGL, profile::Pipeline::Classic> pipeline({pass1, pass2});

    // Use the first pass and then the next
    ASSERT_TRUE(pipeline.hasNext());
    ASSERT_TRUE(pipeline.useNext());
    ASSERT_FALSE(pipeline.useNext());
}

TEST_F(PipelineTest, ResetPipelineTest)
{
    pipeline::Pipeline<api::OpenGL, profile::Pipeline::Classic> pipeline({pass1, pass2});

    pipeline.use(0);
    ASSERT_NO_THROW(pipeline.reset());
    // Add checks to ensure the pipeline is reset to its initial state
}

TEST_F(PipelineTest, PassesCountTest)
{
    pipeline::Pipeline<api::OpenGL, profile::Pipeline::Classic> pipeline({pass1, pass2});

    ASSERT_EQ(pipeline.getPassesCount(), 2);
}

// Additional tests can be added based on other functionalities of the Pipeline class

================================================================================
Contenu du fichier './component-tests/src/graphic/shader/ShaderTests.cpp':
#include <string>
#include <graphic/pipeline/Shader.hpp>

#include <graphic/opengl/profile/Shader.hpp>
#include <graphic/opengl/validator/Validator.hpp>
#include <graphic/opengl/pipeline/component/shader/Reader.hpp>
#include <graphic/opengl/pipeline/component/shader/Loader.hpp>
#include <graphic/opengl/pipeline/component/shader/Freer.hpp>
#include <graphic/opengl/pipeline/component/attribute/Binder.hpp>
#include <graphic/opengl/pipeline/component/attribute/Setter.hpp>
#include <graphic/opengl/pipeline/component/attribute/Unbinder.hpp>
#include <graphic/opengl/pipeline/component/uniform/Setter.hpp>

#include <graphic/opengl/context/ShaderContext.hpp>
#include <OpenGLComponentTests.hpp>
#include <graphic/Api.hpp>
#include <OpenGLComponentTests.hpp>
#include <TestUtils.hpp>

namespace api = cenpy::graphic::api;
namespace context = cenpy::graphic::context;
namespace pipeline = cenpy::graphic::pipeline;
using cenpy::graphic::opengl::profile::Shader::Classic;
using cenpy::test::utils::expectSpecificError;

class ShaderTest : public OpenGLComponentTest
{
};

TEST_F(ShaderTest, CreateShaderVert)
{
    // Arrange
    pipeline::Shader<api::OpenGL, Classic> shader("test-datas/shaders/vertex/good/minimal.vert", context::ShaderType::VERTEX);

    // Act
    ASSERT_NO_THROW(shader.load());

    // Assert
    EXPECT_EQ(shader.getContext()->getShaderID(), 1);
    EXPECT_EQ(shader.getContext()->getShaderType(), context::ShaderType::VERTEX);

    shader.free();
}

TEST_F(ShaderTest, CreateShaderBadVert)
{
    // Arrange
    pipeline::Shader<api::OpenGL, Classic> shader("test-datas/shaders/vertex/bad/minimal.vert", context::ShaderType::VERTEX);

    // Act
    expectSpecificError([&shader]()
                        { shader.load(); },
                        cenpy::common::exception::TraceableException<std::runtime_error>("ERROR::SHADER::COMPILATION_FAILED"));
    // Assert
    EXPECT_EQ(shader.getContext()->getShaderType(), context::ShaderType::VERTEX);

    shader.free();
}

TEST_F(ShaderTest, CreateShaderFrag)
{
    // Arrange
    pipeline::Shader<api::OpenGL, Classic> shader("test-datas/shaders/fragment/good/minimal.frag", context::ShaderType::FRAGMENT);

    // Act
    ASSERT_NO_THROW(shader.load());

    // Assert
    EXPECT_EQ(shader.getContext()->getShaderID(), 1);
    EXPECT_EQ(shader.getContext()->getShaderType(), context::ShaderType::FRAGMENT);

    shader.free();
}

TEST_F(ShaderTest, CreateShaderBadFrag)
{
    // Arrange
    pipeline::Shader<api::OpenGL, Classic> shader("test-datas/shaders/fragment/bad/minimal.frag", context::ShaderType::FRAGMENT);

    // Act
    expectSpecificError([&shader]()
                        { shader.load(); },
                        cenpy::common::exception::TraceableException<std::runtime_error>("ERROR::SHADER::COMPILATION_FAILED"));
    // Assert
    EXPECT_EQ(shader.getContext()->getShaderType(), context::ShaderType::FRAGMENT);

    shader.free();
}

TEST_F(ShaderTest, CreateShaderGeom)
{
    // Arrange
    pipeline::Shader<api::OpenGL, Classic> shader("test-datas/shaders/geometry/good/minimal.geom", context::ShaderType::GEOMETRY);

    // Act
    ASSERT_NO_THROW(shader.load());

    // Assert
    EXPECT_EQ(shader.getContext()->getShaderID(), 1);
    EXPECT_EQ(shader.getContext()->getShaderType(), context::ShaderType::GEOMETRY);

    shader.free();
}

TEST_F(ShaderTest, CreateShaderBadGeom)
{
    // Arrange
    pipeline::Shader<api::OpenGL, Classic> shader("test-datas/shaders/geometry/bad/minimal.geom", context::ShaderType::GEOMETRY);

    // Act
    expectSpecificError([&shader]()
                        { shader.load(); },
                        cenpy::common::exception::TraceableException<std::runtime_error>("ERROR::SHADER::COMPILATION_FAILED"));
    // Assert
    EXPECT_EQ(shader.getContext()->getShaderType(), context::ShaderType::GEOMETRY);

    shader.free();
}

TEST_F(ShaderTest, CreateShaderTesselaionControl)
{
    // Arrange
    pipeline::Shader<api::OpenGL, Classic> shader("test-datas/shaders/tesselaion_control/good/minimal.tesc", context::ShaderType::TESS_CONTROL);

    // Act
    ASSERT_NO_THROW(shader.load());

    // Assert
    EXPECT_EQ(shader.getContext()->getShaderID(), 1);
    EXPECT_EQ(shader.getContext()->getShaderType(), context::ShaderType::TESS_CONTROL);

    shader.free();
}

TEST_F(ShaderTest, CreateShaderBadTesselaionControl)
{
    // Arrange
    pipeline::Shader<api::OpenGL, Classic> shader("test-datas/shaders/tesselaion_control/bad/minimal.tesc", context::ShaderType::TESS_CONTROL);

    // Act
    expectSpecificError([&shader]()
                        { shader.load(); },
                        cenpy::common::exception::TraceableException<std::runtime_error>("ERROR::SHADER::COMPILATION_FAILED"));
    // Assert
    EXPECT_EQ(shader.getContext()->getShaderType(), context::ShaderType::TESS_CONTROL);

    shader.free();
}

TEST_F(ShaderTest, CreateShaderCompute)
{
    // Arrange
    pipeline::Shader<api::OpenGL, Classic> shader("test-datas/shaders/compute/good/minimal.comp", context::ShaderType::COMPUTE);

    // Act
    ASSERT_NO_THROW(shader.load());

    // Assert
    EXPECT_EQ(shader.getContext()->getShaderID(), 1);
    EXPECT_EQ(shader.getContext()->getShaderType(), context::ShaderType::COMPUTE);

    shader.free();
}

TEST_F(ShaderTest, CreateShaderBadCompute)
{
    // Arrange
    pipeline::Shader<api::OpenGL, Classic> shader("test-datas/shaders/compute/bad/minimal.comp", context::ShaderType::COMPUTE);

    // Act
    expectSpecificError([&shader]()
                        { shader.load(); },
                        cenpy::common::exception::TraceableException<std::runtime_error>("ERROR::SHADER::COMPILATION_FAILED"));
    // Assert
    EXPECT_EQ(shader.getContext()->getShaderType(), context::ShaderType::COMPUTE);

    shader.free();
}

================================================================================
Contenu du fichier './include/graphic/Api.hpp':
// Api.hpp

#pragma once

namespace cenpy::graphic
{
    namespace opengl
    {
        namespace validator
        {
            struct Validator;
        }
        namespace context
        {
            class OpenGLShaderContext;
            class OpenGLPassContext;
            class OpenGLUniformContext;
            class OpenGLAttributeContext;
            class OpenGLPipelineContext;
        }
    }
    namespace api
    {
        /**
         * @class OpenGL
         * @brief Encapsulation of the OpenGL context configuration for shader management.
         *
         * The OpenGL class acts as a part of the configuration layer for the shader management system,
         * specifically tailored for the OpenGL graphics API. It defines the type of ShaderContext to
         * be used when working with OpenGL shaders. This class is utilized as a template parameter
         * in the Shader class to provide the necessary OpenGL-specific context, loaders, and freers.
         *
         * Usage:
         *   Shader<OpenGL> shader("path/to/shader", ShaderType::VERTEX);
         *
         * This approach allows for clear and concise configuration, making the shader system adaptable
         * to different graphics APIs by simply changing the template argument.
         */
        class OpenGL
        {
        public:
            using ShaderContext = graphic::opengl::context::OpenGLShaderContext;
            using PassContext = graphic::opengl::context::OpenGLPassContext;
            using UniformContext = graphic::opengl::context::OpenGLUniformContext;
            using AttributeContext = graphic::opengl::context::OpenGLAttributeContext;
            using PipelineContext = graphic::opengl::context::OpenGLPipelineContext;
            using Validator = graphic::opengl::validator::Validator;
        };
    }
}
================================================================================
Contenu du fichier './include/graphic/context/AttributeContext.hpp':
// AttributeContext.hpp

#pragma once
#include <string>
#include <format>
#include <any>
#include <memory>
#include <common/exception/TraceableException.hpp>

namespace cenpy::graphic::context
{
    template <typename API>
    class AttributeContext
    {
    public:
        virtual ~AttributeContext() = default;

        template <typename T>
        std::shared_ptr<T> getValue() const
        {
            if (m_value.has_value())
            {
                try
                {
                    return std::any_cast<std::shared_ptr<T>>(m_value);
                }
                catch (const std::bad_any_cast &)
                {
                    throw cenpy::common::exception::TraceableException<std::runtime_error>(std::format("ERROR::ATTRIBUTE::SET::TYPE_MISMATCH: The type of the value ({}) does not match the type of the attribute variable ({})", typeid(T).name(), typeid(m_value).name()));
                }
            }
            return nullptr;
        }

        template <typename T>
        void setValue(std::shared_ptr<T> value)
        {
            if (m_value.has_value())
            {
                try
                {
                    std::any_cast<std::shared_ptr<T>>(m_value);
                }
                catch (const std::bad_any_cast &)
                {
                    throw cenpy::common::exception::TraceableException<std::runtime_error>(std::format("ERROR::ATTRIBUTE::SET::TYPE_MISMATCH: The type of the value ({}) does not match the type of the attribute variable ({})", typeid(value).name(), typeid(m_value).name()));
                }
            }
            m_value = value;
        }

    private:
        std::any m_value; ///< The value of the attribute variable.
    };
}

================================================================================
Contenu du fichier './include/graphic/context/PassContext.hpp':
// PassContext.hpp

#pragma once
#include <vector>
#include <unordered_map>
#include <memory>
#include <utils.hpp>
#include <graphic/Api.hpp>
#include <graphic/pipeline/Shader.hpp>
#include <graphic/pipeline/Uniform.hpp>
#include <graphic/pipeline/Attribute.hpp>

namespace cenpy::graphic::context
{
    namespace pipeline = cenpy::graphic::pipeline;
    /**
     * @class PassContext
     * @brief Abstract base class for pass context.
     *
     * The PassContext class provides an interface for managing the details and state of a shader pass.
     * This includes a collection of shaders and uniform variables. It serves as a base for API-specific
     * implementations tailored to different graphics APIs.
     */
    template <typename API>
    class PassContext
    {
    public:
        virtual ~PassContext() = default;

        /**
         * @brief Add a shader to the pass.
         * @param shader Shader to add.
         */
        void addShader(std::shared_ptr<pipeline::IShader<API>> shader)
        {
            m_shaders.push_back(shader);
        }

        /*
         * @brief Add uniform to the pass.
         *
         * @param name Name of the uniform to add.
         * @param uniform Uniform to add.
         */
        void addUniform(const std::string &name, std::shared_ptr<pipeline::Uniform<API>> uniform)
        {
            m_uniforms[name] = uniform;
        }

        /**
         * @brief Add attribute to the pass.
         *
         * @param name Name of the attribute to add.
         * @param attribute Attribute to add.
         */
        void addAttribute(const std::string &name, std::shared_ptr<pipeline::IAttribute<API>> attribute)
        {
            m_attributes[name] = attribute;
        }

        /**
         * @brief Get the shader at the given index.
         * @param index Index of the shader to get.
         * @return Shader at the given index.
         */
        [[nodiscard]] std::shared_ptr<pipeline::IShader<API>> getShader(const int &index) const
        {
            return m_shaders[index];
        }

        /**
         * @brief Get the uniform with the given name.
         * @param name Name of the uniform to get.
         * @return Uniform with the given name.
         */
        [[nodiscard]] std::shared_ptr<pipeline::Uniform<API>> getUniform(const std::string &name) const
        {
            if (m_uniforms.contains(name))
            {
                return m_uniforms.at(name);
            }
            return nullptr;
        }

        /**
         * @brief Get the attribute with the given name.
         * @param name Name of the attribute to get.
         * @return Attribute with the given name.
         */
        [[nodiscard]] std::shared_ptr<pipeline::IAttribute<API>> getAttribute(const std::string &name) const
        {
            if (m_attributes.contains(name))
            {
                return m_attributes.at(name);
            }
            return nullptr;
        }

        /**
         * @brief Get the number of shaders in the pass.
         * @return Number of shaders in the pass.
         */
        [[nodiscard]] int getShadersCount() const
        {
            return m_shaders.size();
        }

        /**
         * @brief Get the shaders in the pass.
         * @return Shaders in the pass.
         */
        [[nodiscard]] const std::vector<std::shared_ptr<pipeline::IShader<API>>> &getShaders() const
        {
            return m_shaders;
        }

        /**
         * @brief Get the uniforms in the pass.
         * @return Uniforms in the pass.
         */
        [[nodiscard]] const std::unordered_map<std::string, std::shared_ptr<pipeline::Uniform<API>>, collection_utils::StringHash, collection_utils::StringEqual> &getUniforms() const
        {
            return m_uniforms;
        }

        /**
         * @brief Get the attributes in the pass.
         * @return Attributes in the pass.
         */
        [[nodiscard]] const std::unordered_map<std::string, std::shared_ptr<pipeline::IAttribute<API>>, collection_utils::StringHash, collection_utils::StringEqual> &getAttributes() const
        {
            return m_attributes;
        }

    private:
        std::vector<std::shared_ptr<pipeline::IShader<API>>> m_shaders;
        std::unordered_map<std::string, std::shared_ptr<pipeline::Uniform<API>>, collection_utils::StringHash, collection_utils::StringEqual> m_uniforms;
        std::unordered_map<std::string, std::shared_ptr<pipeline::IAttribute<API>>, collection_utils::StringHash, collection_utils::StringEqual> m_attributes;
    };
}

================================================================================
Contenu du fichier './include/graphic/context/PipelineContext.hpp':
// PipelineContext.hpp

#pragma once

#include <memory>
#include <graphic/Api.hpp>
#include <graphic/pipeline/Pass.hpp>

namespace cenpy::graphic::context
{
    namespace pipeline = cenpy::graphic::pipeline;
    template <typename API>
    class PipelineContext
    {
    public:
        virtual ~PipelineContext() = default;

        void addPass(std::shared_ptr<pipeline::IPass<API>> pass)
        {
            m_passes.push_back(pass);
        }

        [[nodiscard]] std::shared_ptr<pipeline::IPass<API>> getPass(const int &index) const
        {
            return m_passes[index];
        }

        [[nodiscard]] int getPassesCount() const
        {
            return m_passes.size();
        }

        void setCurrentPass(const int &pass)
        {
            m_currentPass = pass;
        }

        [[nodiscard]] int getCurrentPass() const
        {
            return m_currentPass;
        }

    private:
        std::vector<std::shared_ptr<pipeline::IPass<API>>> m_passes;
        int m_currentPass = -1;
    };
}
================================================================================
Contenu du fichier './include/graphic/context/ShaderContext.hpp':
// ShaderContext.hpp

#pragma once

namespace cenpy::graphic::context
{
    enum class ShaderType
    {
        VERTEX,
        FRAGMENT,
        GEOMETRY,
        TESS_CONTROL,
        TESS_EVALUATION,
        COMPUTE
    };

    /**
     * @class ShaderContext
     * @brief Abstract base class for shader context.
     *
     * The ShaderContext class provides an interface for managing shader-specific
     * details and state. It serves as a base for API-specific implementations
     * to handle shader resources and state management in a way that is tailored
     * to each graphics API.
     */
    template <typename API>
    class ShaderContext
    {
    public:
        virtual ~ShaderContext() = default;

        virtual void setShaderType(ShaderType shaderType)
        {
            m_shaderType = shaderType;
        }

        [[nodiscard]] virtual graphic::context::ShaderType getShaderType() const
        {
            return m_shaderType;
        }

        virtual void setShaderPath(const std::string &shaderPath)
        {
            m_shaderPath = shaderPath;
        }

        [[nodiscard]] virtual const std::string &getShaderPath() const
        {
            return m_shaderPath;
        }

        virtual void setShaderCode(const std::string &shaderCode)
        {
            m_shaderCode = shaderCode;
        }

        [[nodiscard]] virtual const std::string &getShaderCode() const
        {
            return m_shaderCode;
        }

    private:
        ShaderType m_shaderType;  ///< Shader type
        std::string m_shaderPath; // Path to the shader source code
        std::string m_shaderCode; // The code of the shader
    };

}
================================================================================
Contenu du fichier './include/graphic/context/UniformContext.hpp':
// UniformContext.hpp

#pragma once
#include <string>
#include <format>
#include <any>
#include <common/exception/TraceableException.hpp>

namespace cenpy::graphic::context
{
    template <typename API>
    class UniformContext
    {
    public:
        virtual ~UniformContext() = default;

        template <typename T>
        const T &getValue() const
        {
            if (m_value.has_value())
            {
                try
                {
                    std::any_cast<T>(&m_value);
                }
                catch (const std::bad_any_cast &)
                {
                    throw cenpy::common::exception::TraceableException<std::runtime_error>(std::format("ERROR::UNIFORM::SET::TYPE_MISMATCH: The type of the value ({}) does not match the type of the uniform variable ({})", typeid(T).name(), typeid(m_value).name()));
                }
            }
            return *std::any_cast<T>(&m_value);
        }

        template <typename T>
        void setValue(const T &value)
        {
            try
            {
                std::any_cast<T>(&m_value);
            }
            catch (const std::bad_any_cast &)
            {
                throw cenpy::common::exception::TraceableException<std::runtime_error>(std::format("ERROR::UNIFORM::SET::TYPE_MISMATCH: The type of the value ({}) does not match the type of the uniform variable ({})", typeid(value).name(), typeid(m_value).name()));
            }
            m_value = value;
        }

    private:
        std::any m_value; ///< The value of the uniform variable.
    };
}
================================================================================
Contenu du fichier './include/graphic/displayable/Drawable.hpp':
#pragma once
#include <iostream>
#include <graphic/scene/SceneGraph.hpp>

// Simple Drawable
class Drawable : public SceneNode
{
public:
    void draw() const override
    {
        // Implement drawing logic for the Drawable
        std::cout << "Drawing a Drawable\n";
    }
};
================================================================================
Contenu du fichier './include/graphic/displayable/Drawable2D.hpp':
#pragma once

#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <iostream>
#include <vector>
#include <fstream>
#include <sstream>
#include <cmath>

class Drawable2D : public SceneNode
{
public:
    Drawable2D(float x, float y, float size)
    {
        // Calculate the coordinates of the other vertices based on the upper left vertex and size
        GLfloat vertices[] = {
            // Positions      // Texture Coords
            x + size, y, 0.0f, 1.0f, 1.0f,        // Top Right
            x + size, y - size, 0.0f, 1.0f, 0.0f, // Bottom Right
            x, y - size, 0.0f, 0.0f, 0.0f,        // Bottom Left
            x, y, 0.0f, 0.0f, 1.0f                // Top Left
        };

        // Define indices to form two triangles for a square
        GLuint indices[] = {
            0, 1, 3, // First Triangle
            1, 2, 3  // Second Triangle
        };

        // Generate vertex array object (VAO), vertex buffer object (VBO), and element buffer object (EBO)
        glGenVertexArrays(1, &VAO);
        glGenBuffers(1, &VBO);
        glGenBuffers(1, &EBO);

        // Bind the vertex array object (VAO)
        glBindVertexArray(VAO);

        // Bind and fill the vertex buffer object (VBO) with vertex data
        glBindBuffer(GL_ARRAY_BUFFER, VBO);
        glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

        // Bind and fill the element buffer object (EBO) with index data
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);

        // Specify the vertex attribute pointers for positions and texture coordinates
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(GLfloat), (GLvoid *)0);
        glEnableVertexAttribArray(0);

        glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(GLfloat), (GLvoid *)(3 * sizeof(GLfloat)));
        glEnableVertexAttribArray(1);

        // Unbind the vertex array object (VAO) to prevent accidental modification
        glBindVertexArray(0);
    }

    void draw() const override
    {
        m_shader.use();

        glBindVertexArray(VAO);
        glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
        glBindVertexArray(0);
    }

private:
    /**
     * @brief The vertex array object
     *
     * @details A VAO is an OpenGL object that stores the configuration of vertex attribute pointers and bindings.
     * It encapsulates the setup for rendering with VBOs, specifying how vertex data is organized and how it should be interpreted by shaders.
     * VAOs help simplify the process of switching between different sets of vertex data.
     */
    GLuint VAO;

    /**
     * @brief The vertex buffer object
     *
     * @details A VBO is a buffer in the GPU's memory that stores vertex data, such as positions, colors, normals, and texture coordinates.
     * Instead of sending vertex data to the GPU for each frame, you can store it in a VBO, which allows for more efficient rendering
     */
    GLuint VBO;

    /**
     * @brief The element buffer object
     *
     * @details An EBO, also known as an Index Buffer, is a buffer in the GPU's memory that stores indices.
     * Instead of duplicating vertex data for shared vertices among multiple triangles, you can use an EBO to reference shared vertices using indices.
     * This reduces memory usage and allows for more efficient storage of geometry data.
     */
    GLuint EBO;
    Shader m_shader{"path/to/2d_vertex_shader.glsl", "path/to/2d_fragment_shader.glsl"};
    Texture m_texture{"path/to/texture.png"};
};
================================================================================
Contenu du fichier './include/graphic/opengl/context/AttributeContext.hpp':
// AttributeContext.hpp

#pragma once
#include <GL/glew.h>
#include <graphic/Api.hpp>
#include <graphic/context/AttributeContext.hpp>

namespace cenpy::graphic
{
    namespace opengl::pipeline::component::attribute
    {
        template <auto PROFILE>
        class OpenGLBinder;
        template <typename A>
        class OpenGLSetter;
        template <auto PROFILE>
        class OpenGLUnbinder;
    }

    namespace opengl::context
    {
        class OpenGLAttributeContext : public graphic::context::AttributeContext<graphic::api::OpenGL>
        {
        public:
            template <auto PROFILE>
            using Binder = opengl::pipeline::component::attribute::OpenGLBinder<PROFILE>;
            template <typename A>
            using Setter = opengl::pipeline::component::attribute::OpenGLSetter<A>;
            template <auto PROFILE>
            using Unbinder = opengl::pipeline::component::attribute::OpenGLUnbinder<PROFILE>;

            void setAttributeID(GLuint attributeId)
            {
                m_attributeId = attributeId;
            }

            GLuint getAttributeID() const
            {
                return m_attributeId;
            }

            GLuint getBufferID() const
            {
                return m_bufferId;
            }

            void setBufferID(GLuint bufferId)
            {
                m_bufferId = bufferId;
            }

            void setGLSize(GLuint size)
            {
                m_size = size;
            }

            GLuint getGLSize() const
            {
                return m_size;
            }

            GLenum getGLType() const
            {
                return m_type;
            }

            void setGLType(GLenum type)
            {
                m_type = type;
            }

            void setGLUsage(GLenum usage)
            {
                if (usage != GL_STREAM_DRAW && usage != GL_STATIC_DRAW && usage != GL_DYNAMIC_DRAW)
                {
                    throw cenpy::common::exception::TraceableException<std::runtime_error>(std::format("ERROR::ATTRIBUTE::SET::DRAWING_MODE_NOT_SUPPORTED: The drawing mode ({}) is not supported", usage));
                }
                m_usage = usage;
            }

            GLenum getGLUsage() const
            {
                return m_usage;
            }

        private:
            GLuint m_attributeId; ///< OpenGL attribute ID
            GLuint m_size;        ///< The size of the attribute variable.
            GLenum m_type;        ///< The type of the attribute variable.
            GLuint m_bufferId;    ///< OpenGL VBO buffer ID
            GLenum m_usage;       ///< The drawing mode of the attribute variable.
        };
    }
}
================================================================================
Contenu du fichier './include/graphic/opengl/context/PassContext.hpp':
// PassContext.hpp

#pragma once

#include <GL/glew.h>
#include <graphic/Api.hpp>
#include <graphic/context/PassContext.hpp>

namespace cenpy::graphic
{
    namespace opengl::pipeline::component::pass
    {
        template <auto PROFILE>
        class OpenGLLoader;
        template <auto PROFILE>
        class OpenGLPassFreer;
        template <auto PROFILE>
        class OpenGLShaderAttacher;
        template <auto PROFILE>
        class OpenGLPassUniformReader;
        template <auto PROFILE>
        class OpenGLPassAttributeReader;
        template <auto PROFILE>
        class OpenGLPassUser;
    }

    namespace opengl::context
    {
        /**
         * @class OpenGLPassContext
         * @brief OpenGL-specific implementation of PassContext.
         *
         * OpenGLPassContext manages the details and state of a shader pass for OpenGL.
         * This includes handling of OpenGL-specific data such as pipeline IDs, as well
         * as the list of shaders and uniform variables.
         */
        class OpenGLPassContext : public graphic::context::PassContext<graphic::api::OpenGL>
        {
        public:
            template <auto PROFILE>
            using Loader = opengl::pipeline::component::pass::OpenGLLoader<PROFILE>;
            template <auto PROFILE>
            using Freer = opengl::pipeline::component::pass::OpenGLPassFreer<PROFILE>;
            template <auto PROFILE>
            using ShaderAttacher = opengl::pipeline::component::pass::OpenGLShaderAttacher<PROFILE>;
            template <auto PROFILE>
            using UniformReader = opengl::pipeline::component::pass::OpenGLPassUniformReader<PROFILE>;
            template <auto PROFILE>
            using AttributeReader = opengl::pipeline::component::pass::OpenGLPassAttributeReader<PROFILE>;
            template <auto PROFILE>
            using User = opengl::pipeline::component::pass::OpenGLPassUser<PROFILE>;

            void setPassID(GLuint passID)
            {
                m_passID = passID;
            }

            GLuint getPassID() const
            {
                return m_passID;
            }

        private:
            GLuint m_passID; // OpenGL pipeline ID
        };
    }
}
================================================================================
Contenu du fichier './include/graphic/opengl/context/PipelineContext.hpp':
// PipelineContext.hpp

#pragma once

#include <graphic/Api.hpp>
#include <graphic/context/PipelineContext.hpp>

namespace cenpy::graphic
{
    namespace opengl::pipeline::component::pipeline
    {
        template <auto PROFILE>
        class OpenGLPipelineUser;
        template <auto PROFILE>
        class OpenGLPipelineResetter;
    }
    namespace opengl::context
    {
        class OpenGLPipelineContext : public graphic::context::PipelineContext<graphic::api::OpenGL>
        {
        public:
            template <auto PROFILE>
            using User = opengl::pipeline::component::pipeline::OpenGLPipelineUser<PROFILE>;
            template <auto PROFILE>
            using Resetter = opengl::pipeline::component::pipeline::OpenGLPipelineResetter<PROFILE>;
        };
    }
}
================================================================================
Contenu du fichier './include/graphic/opengl/context/ShaderContext.hpp':
// ShaderContext.hpp

#pragma once
#include <GL/glew.h>
#include <graphic/Api.hpp>
#include <graphic/context/ShaderContext.hpp>
#include <common/exception/TraceableException.hpp>

namespace cenpy::graphic
{

    namespace opengl::pipeline::component::shader
    {
        template <auto PROFILE>
        class OpenGLShaderLoader;
        template <auto PROFILE>
        class OpenGLShaderFreer;
        template <auto PROFILE>
        class OpenGLShaderReader;
    }
    namespace opengl::context
    {
        /**
         * @class OpenGLShaderContext
         * @brief OpenGL-specific implementation of ShaderContext.
         *
         * OpenGLShaderContext manages OpenGL-specific details and state for shaders.
         * It provides mechanisms to store and retrieve OpenGL-specific data, such as
         * shader IDs, necessary for shader operations in an OpenGL context.
         */
        class OpenGLShaderContext : public graphic::context::ShaderContext<graphic::api::OpenGL>
        {
        public:
            template <auto PROFILE>
            using Loader = opengl::pipeline::component::shader::OpenGLShaderLoader<PROFILE>;
            template <auto PROFILE>
            using Freer = opengl::pipeline::component::shader::OpenGLShaderFreer<PROFILE>;
            template <auto PROFILE>
            using Reader = opengl::pipeline::component::shader::OpenGLShaderReader<PROFILE>;

            void setShaderID(GLuint shaderID)
            {
                m_shaderID = shaderID;
            }

            GLuint getShaderID() const
            {
                return m_shaderID;
            }

            /**
             * @brief Converts the ShaderType enum to the corresponding OpenGL shader type.
             *
             * @return The OpenGL shader type.
             * @throws TraceableException if the shader type is unknown.
             */
            GLenum getGLShaderType() const
            {
                switch (getShaderType())
                {
                    using enum graphic::context::ShaderType;
                case VERTEX:
                    return GL_VERTEX_SHADER;
                case FRAGMENT:
                    return GL_FRAGMENT_SHADER;
                case GEOMETRY:
                    return GL_GEOMETRY_SHADER;
                case TESS_CONTROL:
                    return GL_TESS_CONTROL_SHADER;
                case TESS_EVALUATION:
                    return GL_TESS_EVALUATION_SHADER;
                case COMPUTE:
                    return GL_COMPUTE_SHADER;
                default:
                    throw common::exception::TraceableException<std::runtime_error>("ERROR::SHADER::UNKNOWN_SHADER_TYPE");
                }
            }

        private:
            GLuint m_shaderID; ///< OpenGL shader ID
        };
    }
}
================================================================================
Contenu du fichier './include/graphic/opengl/context/UniformContext.hpp':
// UniformContext.hpp

#pragma once
#include <GL/glew.h>
#include <graphic/Api.hpp>
#include <graphic/context/UniformContext.hpp>

namespace cenpy::graphic
{

    namespace opengl::pipeline::component::uniform
    {
        template <typename U>
        class OpenGLUniformSetter;
    }
    namespace opengl::context
    {
        class OpenGLUniformContext : public graphic::context::UniformContext<graphic::api::OpenGL>
        {
        public:
            template <typename T>
            using Setter = opengl::pipeline::component::uniform::OpenGLUniformSetter<T>;

            void setUniformID(GLuint uniformId)
            {
                m_uniformId = uniformId;
            }

            GLuint getUniformID() const
            {
                return m_uniformId;
            }

            void setGLType(GLenum type)
            {
                m_type = type;
            }

            GLenum getGLType() const
            {
                return m_type;
            }

            void setSize(GLuint size)
            {
                m_size = size;
            }

            GLuint getGLSize() const
            {
                return m_size;
            }

        private:
            GLuint m_uniformId; ///< OpenGL shader ID
            GLuint m_size;      ///< The size of the uniform variable.
            GLenum m_type;      ///< The type of the uniform variable.
        };
    }
}
================================================================================
Contenu du fichier './include/graphic/opengl/pipeline/component/attribute/Binder.hpp':
// file: Binder

#pragma once

#include <GL/glew.h>
#include <string>
#include <memory>
#include <any>
#include <graphic/opengl/context/AttributeContext.hpp>
#include <graphic/Api.hpp>
#include <graphic/opengl/profile/Attribute.hpp>

namespace cenpy::graphic::opengl::pipeline::component::attribute
{
    template <auto PROFILE>
    class OpenGLBinder
    {
    };

    template <>
    class OpenGLBinder<graphic::opengl::profile::Attribute::Classic>
    {
    public:
        static void on(std::shared_ptr<typename graphic::api::OpenGL::AttributeContext> attribute)
        {
            if (!attribute)
            {
                throw cenpy::common::exception::TraceableException<std::runtime_error>(std::format("ERROR::ATTRIBUTE::SET::NON_OPENGL_CONTEXT"));
            }
            if (attribute->getBufferID() == 0)
            {
                unsigned int VBO;
                glGenBuffers(1, &VBO);
                attribute->setBufferID(VBO);
            }
            glBindBuffer(GL_ARRAY_BUFFER, attribute->getBufferID());
        }
    };
}

================================================================================
Contenu du fichier './include/graphic/opengl/pipeline/component/attribute/Setter.hpp':
// file: Setter

#pragma once

#include <GL/glew.h>
#include <string>
#include <memory>
#include <any>
#include <graphic/opengl/context/AttributeContext.hpp>
#include <graphic/Api.hpp>
#include <graphic/opengl/profile/Attribute.hpp>

namespace cenpy::graphic::opengl::pipeline::component::attribute
{
    template <typename A>
    class OpenGLSetter
    {
    public:
        static void on(std::shared_ptr<typename graphic::api::OpenGL::AttributeContext> attribute)
        {
            if (!attribute)
            {
                throw cenpy::common::exception::TraceableException<std::runtime_error>(std::format("ERROR::ATTRIBUTE::SET::NON_OPENGL_CONTEXT"));
            }
            if (attribute->getBufferID() == 0)
            {
                throw cenpy::common::exception::TraceableException<std::runtime_error>(std::format("ERROR::ATTRIBUTE::SET::BUFFER_ID_NOT_SET"));
            }
            std::shared_ptr<A> attrValue = attribute->getValue<A>();
            glBufferData(GL_ARRAY_BUFFER, sizeof(attrValue.get()), attrValue.get(), attribute->getGLUsage());
            glVertexAttribPointer(attribute->getAttributeID(), attribute->getGLSize(), attribute->getGLType(), GL_FALSE, sizeof(attrValue.get()), (void *)nullptr);
        }
    };
}

================================================================================
Contenu du fichier './include/graphic/opengl/pipeline/component/attribute/Unbinder.hpp':
// file: Unbinder

#pragma once

#include <GL/glew.h>
#include <string>
#include <memory>
#include <any>
#include <graphic/opengl/context/AttributeContext.hpp>
#include <graphic/Api.hpp>
#include <graphic/opengl/profile/Attribute.hpp>

namespace cenpy::graphic::opengl::pipeline::component::attribute
{
    template <auto PROFILE>
    class OpenGLUnbinder
    {
    };

    template <>
    class OpenGLUnbinder<graphic::opengl::profile::Attribute::Classic>
    {
    public:
        static void on(std::shared_ptr<typename graphic::api::OpenGL::AttributeContext> attribute)
        {
            if (!attribute)
            {
                throw cenpy::common::exception::TraceableException<std::runtime_error>(std::format("ERROR::ATTRIBUTE::UNBIND::NON_OPENGL_CONTEXT"));
            }
            if (attribute->getBufferID() == 0)
            {
                throw cenpy::common::exception::TraceableException<std::runtime_error>(std::format("ERROR::ATTRIBUTE::UNBIND::BUFFER_ID_NOT_SET"));
            }
            glBindBuffer(GL_ARRAY_BUFFER, 0);
        }
    };
}

================================================================================
Contenu du fichier './include/graphic/opengl/pipeline/component/pass/AttributeReader.hpp':
#pragma once

#include <GL/glew.h>
#include <memory>
#include <graphic/Api.hpp>
#include <graphic/opengl/context/PassContext.hpp>
#include <common/exception/TraceableException.hpp>
#include <graphic/pipeline/Attribute.hpp>
#include <graphic/opengl/profile/Pass.hpp>
#include <graphic/opengl/profile/Attribute.hpp>
#include <graphic/opengl/context/AttributeContext.hpp>

namespace cenpy::graphic::opengl::pipeline::component::pass
{
    /**
     * @class OpenGLAttributeReader
     *
     * This class specializes in reading uniform variables from an OpenGL shader pipeline.
     * It extracts the details of each uniform and populates them into the provided map.
     */
    template <auto PROFILE>
    class OpenGLPassAttributeReader
    {
    };

    template <>
    class OpenGLPassAttributeReader<graphic::opengl::profile::Pass::Classic>
    {
    public:
        static void on(std::shared_ptr<typename graphic::api::OpenGL::PassContext> openglContext)
        {
            if (!openglContext)
            {
                throw common::exception::TraceableException<std::runtime_error>("ERROR::PASS::NON_OPENGL_CONTEXT");
            }

            GLuint passID = openglContext->getPassID();
            if (passID == 0)
            {
                throw common::exception::TraceableException<std::runtime_error>("ERROR::PASS::INVALID_PROGRAM_ID");
            }

            GLint numAttributes = 0;
            glGetProgramiv(passID, GL_ACTIVE_ATTRIBUTES, &numAttributes);

            for (GLint i = 0; i < numAttributes; ++i)
            {
                char attributeName[256];
                GLsizei nameLength = 0;
                GLint size = 0;
                GLenum type = 0;
                glGetActiveAttrib(passID, i, sizeof(attributeName), &nameLength, &size, &type, attributeName);

                GLuint location = glGetAttribLocation(passID, attributeName);

                // Create an Attribute object and store it in the context
                auto attributeContext = std::make_shared<graphic::api::OpenGL::AttributeContext>();
                attributeContext->setAttributeID(location);
                attributeContext->setGLSize(size);
                attributeContext->setGLType(type);

                // Known limitation of OpenGL: Attributes profile are driven by Pass profile
                auto attribute = std::make_shared<graphic::pipeline::Attribute<graphic::api::OpenGL, graphic::opengl::profile::Attribute::Classic>>(attributeContext);
                openglContext->addAttribute(std::string(attributeName), attribute);
            }
        }
    };
}

================================================================================
Contenu du fichier './include/graphic/opengl/pipeline/component/pass/Freer.hpp':
#pragma once

#include <memory>
#include <graphic/Api.hpp>
#include <GL/glew.h>
#include <iostream>
#include <graphic/opengl/context/PassContext.hpp>
#include <graphic/opengl/context/ShaderContext.hpp>
#include <common/exception/TraceableException.hpp>
#include <graphic/opengl/profile/Pass.hpp>

namespace cenpy::graphic::opengl::pipeline::component::pass
{
    /**
     * @class OpenGLPassFreer
     * @brief OpenGL implementation of IPassFreer.
     *
     * Handles the freeing of resources for an OpenGL shader pass, including detaching shaders
     * and deleting the OpenGL pipeline.
     */
    template <auto PROFILE>
    class OpenGLPassFreer
    {
    };

    template <>
    class OpenGLPassFreer<graphic::opengl::profile::Pass::Classic>
    {
    public:
        static void on(std::shared_ptr<typename graphic::api::OpenGL::PassContext> openglContext)
        {

            if (!openglContext)
            {
                throw common::exception::TraceableException<std::runtime_error>("ERROR::SHADER::NON_OPENGL_CONTEXT");
            }

            GLuint passID = openglContext->getPassID();
            if (passID != 0)
            {
                // Optionally detach shaders before deleting the pipeline
                for (const auto &shader : openglContext->getShaders())
                {
                    if (auto oglShaderContext = shader->getContext())
                    {
                        glDetachShader(passID, oglShaderContext->getShaderID());
                    }
                }

                // Delete the OpenGL pipeline
                glDeleteProgram(passID);
                openglContext->setPassID(0); // Reset the pipeline ID in the context
            }
        }
    };
}

================================================================================
Contenu du fichier './include/graphic/opengl/pipeline/component/pass/Loader.hpp':
#pragma once

#include <GL/glew.h>
#include <memory>
#include <graphic/Api.hpp>
#include <graphic/opengl/context/PassContext.hpp>
#include <graphic/opengl/pipeline/component/pass/ShaderAttacher.hpp>
#include <graphic/opengl/profile/Pass.hpp>

namespace cenpy::graphic::opengl::pipeline::component::pass
{
    template <auto PROFILE>
    class OpenGLLoader
    {
    };

    template <>
    class OpenGLLoader<graphic::opengl::profile::Pass::Classic>
    {
    public:
        static void on(std::shared_ptr<typename graphic::api::OpenGL::PassContext> openglContext)
        {
            if (!openglContext)
            {
                throw common::exception::TraceableException<std::runtime_error>(std::format("ERROR::SHADER::PROGRAM::NON_OPENGL_CONTEXT"));
            }

            GLuint passID = glCreateProgram();
            if (passID == 0)
            {
                throw common::exception::TraceableException<std::runtime_error>(std::format("ERROR::SHADER::PROGRAM_CREATION_FAILED\nFailed to create shader pipeline."));
            }

            // Save the created pipeline ID in the context
            openglContext->setPassID(passID);
            cenpy::graphic::api::OpenGL::PassContext::ShaderAttacher<graphic::opengl::profile::Pass::Classic>::on(openglContext);

            // Link the pipeline
            glLinkProgram(passID);

            if (!checkLinkErrors(passID))
            {
                glDeleteProgram(passID);
                throw common::exception::TraceableException<std::runtime_error>(std::format("ERROR::SHADER::PROGRAM::LINK_FAILED"));
            }
        }

        /**
         * @brief Checks for link errors in an OpenGL pipeline.
         * @param passID The ID of the OpenGL pipeline to check.
         * @return True if no linking errors are found, false otherwise.
         */
        static bool
        checkLinkErrors(GLuint passID)
        {
            GLint isLinked = 0;
            glGetProgramiv(passID, GL_LINK_STATUS, &isLinked);
            if (isLinked == GL_FALSE)
            {
                GLint maxLength = 10000;
                glGetProgramiv(passID, GL_INFO_LOG_LENGTH, &maxLength);

                std::vector<GLchar> infoLog(maxLength);
                glGetProgramInfoLog(passID, maxLength, &maxLength, &infoLog[0]);

                std::cerr << "Pipeline link error: " << infoLog.data() << std::endl;
                return false;
            }
            return true;
        }
    };
}

================================================================================
Contenu du fichier './include/graphic/opengl/pipeline/component/pass/ShaderAttacher.hpp':
#pragma once

#include <GL/glew.h>
#include <memory>
#include <graphic/Api.hpp>
#include <graphic/opengl/context/PassContext.hpp>
#include <graphic/opengl/context/ShaderContext.hpp>
#include <graphic/opengl/profile/Pass.hpp>

namespace cenpy::graphic::opengl::pipeline::component::pass
{
    /**
     * @class OpenGLPassAttacher
     * @brief OpenGL implementation of IShaderAttacher.
     *
     * This class implements the shader attaching process for an OpenGL shader pass.
     * It attaches all shaders within the given PassContext to an OpenGL pipeline.
     */
    template <auto PROFILE>
    class OpenGLShaderAttacher
    {
    };

    template <>
    class OpenGLShaderAttacher<graphic::opengl::profile::Pass::Classic>
    {
    public:
        /**
         * @brief Attach shaders to the pass in OpenGL context.
         * @param context PassContext containing pass details specific to OpenGL.
         *
         * This implementation casts the generic PassContext to an OpenGLPassContext,
         * and attaches each shader to the OpenGL pipeline. If the context casting fails
         * or if any shader context is invalid, an exception is thrown.
         */
        static void on(std::shared_ptr<typename graphic::api::OpenGL::PassContext> openglContext)
        {
            if (!openglContext)
            {
                throw common::exception::TraceableException<std::runtime_error>("ERROR::SHADER::NON_OPENGL_CONTEXT");
            }

            GLuint passID = openglContext->getPassID();
            if (passID == 0)
            {
                throw common::exception::TraceableException<std::runtime_error>("ERROR::SHADER::INVALID_PROGRAM_ID");
            }

            for (const auto &shader : openglContext->getShaders())
            {
                glAttachShader(passID, shader->getContext()->getShaderID());
            }
        }
    };

}

================================================================================
Contenu du fichier './include/graphic/opengl/pipeline/component/pass/UniformReader.hpp':
#pragma once

#include <GL/glew.h>
#include <memory>
#include <graphic/Api.hpp>
#include <graphic/opengl/context/PassContext.hpp>
#include <common/exception/TraceableException.hpp>
#include <graphic/opengl/profile/Pass.hpp>

namespace cenpy::graphic::opengl::pipeline::component::pass
{
    /**
     * @class OpenGLUniformReader
     * @brief OpenGL implementation of the IPassUniformReader interface.
     *
     * This class specializes in reading uniform variables from an OpenGL shader pipeline.
     * It extracts the details of each uniform and populates them into the provided map.
     */
    template <auto PROFILE>
    class OpenGLPassUniformReader
    {
    };

    template <>
    class OpenGLPassUniformReader<graphic::opengl::profile::Pass::Classic>
    {
    public:
        static void on(std::shared_ptr<typename graphic::api::OpenGL::PassContext> openglContext)
        {
            if (!openglContext)
            {
                throw common::exception::TraceableException<std::runtime_error>("ERROR::PASS::NON_OPENGL_CONTEXT");
            }

            GLuint passID = openglContext->getPassID();
            if (passID == 0)
            {
                throw common::exception::TraceableException<std::runtime_error>("ERROR::PASS::INVALID_PROGRAM_ID");
            }

            GLint numUniforms = 0;
            glGetProgramiv(passID, GL_ACTIVE_UNIFORMS, &numUniforms);

            for (GLint i = 0; i < numUniforms; ++i)
            {
                char uniformName[256];
                GLsizei nameLength = 0;
                GLsizei size = 0;
                GLenum type = 0;
                glGetActiveUniform(passID, i, sizeof(uniformName), &nameLength, &size, &type, uniformName);

                GLuint location = glGetUniformLocation(passID, uniformName);

                // Create a Uniform object and store it in the map
                auto uniformContext = std::make_shared<graphic::api::OpenGL::UniformContext>();
                uniformContext->setUniformID(location);
                uniformContext->setGLType(type);
                // Known limitation of OpenGL: Uniforms profile are driven by Pass profile
                auto uniform = std::make_shared<graphic::pipeline::Uniform<graphic::api::OpenGL>>(uniformContext);
                openglContext->addUniform(std::string(uniformName), uniform);
            }
        }
    };
}

================================================================================
Contenu du fichier './include/graphic/opengl/pipeline/component/pass/User.hpp':
#pragma once

#include <GL/glew.h>
#include <format>
#include <memory>
#include <graphic/Api.hpp>
#include <graphic/opengl/context/PassContext.hpp>
#include <common/exception/TraceableException.hpp>
#include <graphic/opengl/pipeline/component/pass/User.hpp>
#include <graphic/opengl/profile/Pass.hpp>

namespace cenpy::graphic::opengl::pipeline::component::pass
{
    /**
     * @class OpenGLPassUser
     * @brief OpenGL implementation of IPassUser.
     *
     * Handles the activation of a shader pass in an OpenGL context. This includes setting the
     * current OpenGL pipeline to the one associated with the shader pass.
     */
    template <auto PROFILE>
    class OpenGLPassUser
    {
    };

    template <>
    class OpenGLPassUser<graphic::opengl::profile::Pass::Classic>
    {
    public:
        static void on(std::shared_ptr<typename graphic::api::OpenGL::PassContext> openglContext)
        {
            if (!openglContext)
            {
                // Throw an exception if the context is not valid for OpenGL
                throw common::exception::TraceableException<std::runtime_error>(std::format("ERROR::SHADER::NON_OPENGL_CONTEXT"));
            }

            // Set the OpenGL pipeline for this pass as the current active pipeline
            glUseProgram(openglContext->getPassID());
        }
    };
}

================================================================================
Contenu du fichier './include/graphic/opengl/pipeline/component/pipeline/Resetter.hpp':
#pragma once

#include <memory>
#include <graphic/Api.hpp>
#include <common/exception/TraceableException.hpp>
#include <graphic/opengl/context/PipelineContext.hpp>
#include <graphic/opengl/profile/Pipeline.hpp>

namespace cenpy::graphic::opengl::pipeline::component::pipeline
{
    template <auto PROFILE>
    class OpenGLPipelineResetter
    {
    };

    template <>
    class OpenGLPipelineResetter<graphic::opengl::profile::Pipeline::Classic>
    {
    public:
        static void on(std::shared_ptr<typename graphic::api::OpenGL::PipelineContext> context)
        {
            if (!context)
            {
                throw common::exception::TraceableException<std::runtime_error>(std::format("ERROR::SHADER::NON_VALID_CONTEXT"));
            }
            context->setCurrentPass(-1);
        }
    };
}

================================================================================
Contenu du fichier './include/graphic/opengl/pipeline/component/pipeline/User.hpp':
#pragma once

#include <memory>
#include <graphic/Api.hpp>
#include <common/exception/TraceableException.hpp>
#include <graphic/opengl/context/PipelineContext.hpp>
#include <graphic/opengl/profile/Pipeline.hpp>

namespace cenpy::graphic::opengl::pipeline::component::pipeline
{
    template <auto PROFILE>
    class OpenGLPipelineUser
    {
    };

    template <>
    class OpenGLPipelineUser<graphic::opengl::profile::Pipeline::Classic>
    {
    public:
        static void on(std::shared_ptr<typename graphic::api::OpenGL::PipelineContext> context)
        {
            if (!context)
            {
                throw common::exception::TraceableException<std::runtime_error>(std::format("ERROR::SHADER::NON_VALID_CONTEXT"));
            }
            context->getPass(context->getCurrentPass())->use();
        }
    };
}

================================================================================
Contenu du fichier './include/graphic/opengl/pipeline/component/shader/Freer.hpp':
// file: Freer.hpp

#pragma once

#include <string>
#include <memory>
#include <graphic/Api.hpp>
#include <graphic/opengl/context/ShaderContext.hpp>
#include <graphic/opengl/profile/Shader.hpp>

namespace cenpy::graphic::opengl::pipeline::component::shader
{
    /**
     * @class OpenGLShaderFreer
     * @brief OpenGL implementation of IShaderFreer.
     *
     * OpenGLShaderFreer is responsible for freeing or deleting shaders in an OpenGL context.
     * It ensures that OpenGL shader objects are properly deleted and resources are released.
     */
    template <auto PROFILE>
    class OpenGLShaderFreer
    {
    };

    template <>
    class OpenGLShaderFreer<graphic::opengl::profile::Shader::Classic>
    {
    public:
        static void on(std::shared_ptr<typename graphic::api::OpenGL::ShaderContext> openglContext)
        {
            GLuint shaderID = openglContext->getShaderID();

            if (shaderID != 0)
            {
                glDeleteShader(shaderID);
                openglContext->setShaderID(0); // Reset the shader ID in the context
            }
        }
    };
}

================================================================================
Contenu du fichier './include/graphic/opengl/pipeline/component/shader/Loader.hpp':
// file: Loader.hpp

#pragma once

#include <string>
#include <format>
#include <memory>
#include <graphic/Api.hpp>
#include <graphic/opengl/context/ShaderContext.hpp>
#include <graphic/opengl/profile/Shader.hpp>

namespace cenpy::graphic::opengl::pipeline::component::shader
{
    /**
     * @class OpenGLShaderLoader
     * @brief OpenGL implementation of IShaderLoader.
     *
     * OpenGLShaderLoader is responsible for loading shaders in an OpenGL context.
     * It compiles the shader source code and manages shader objects in OpenGL.
     */
    template <auto PROFILE>
    class OpenGLShaderLoader
    {
    };

    template <>
    class OpenGLShaderLoader<graphic::opengl::profile::Shader::Classic>
    {
    public:
        static void on(std::shared_ptr<typename graphic::api::OpenGL::ShaderContext> openglContext)
        {
            // Create a shader object
            GLuint shaderID = glCreateShader(openglContext->getGLShaderType());
            const char *shaderCodeCStr = openglContext->getShaderCode().c_str();
            glShaderSource(shaderID, 1, &shaderCodeCStr, nullptr);
            glCompileShader(shaderID);

            // Check for shader compile errors
            if (!checkCompileErrors(shaderID))
            {
                glDeleteShader(shaderID); // Don't leak the shader.
                throw common::exception::TraceableException<std::runtime_error>(std::format("ERROR::SHADER::COMPILATION_FAILED\n"));
            }

            // Store the shader ID in the OpenGL context
            openglContext->setShaderID(shaderID);
        }

    private:
        static bool checkCompileErrors(GLuint shaderID)
        {
            GLint success;
            glGetShaderiv(shaderID, GL_COMPILE_STATUS, &success);
            if (!success)
            {
                GLchar infoLog[512];
                glGetShaderInfoLog(shaderID, 512, nullptr, infoLog);
                std::cerr << "Shader compilation error: " << infoLog << std::endl;
                return false;
            }
            return true;
        }
    };
}

================================================================================
Contenu du fichier './include/graphic/opengl/pipeline/component/shader/Reader.hpp':
// file: Reader.hpp

#pragma once

#include <string>
#include <graphic/Api.hpp>
#include <graphic/opengl/context/ShaderContext.hpp>
#include <fstream>
#include <sstream>
#include <format>
#include <common/exception/TraceableException.hpp>
#include <graphic/opengl/profile/Shader.hpp>

namespace cenpy::graphic::opengl::pipeline::component::shader
{
    template <auto PROFILE>
    class OpenGLShaderReader
    {
    };

    template <>
    class OpenGLShaderReader<graphic::opengl::profile::Shader::Classic>
    {
    public:
        static void on(std::shared_ptr<typename graphic::api::OpenGL::ShaderContext> context)
        {
            context->setShaderCode("");
            std::ifstream shaderFile;

            // ensure ifstream objects can throw exceptions
            shaderFile.exceptions(std::ifstream::badbit);

            try
            {
                shaderFile.open(context->getShaderPath());
                std::stringstream shaderStream;

                shaderStream << shaderFile.rdbuf(); // read file's buffer contents into streams
                shaderFile.close();

                context->setShaderCode(shaderStream.str());
            }
            catch (std::ifstream::failure &e)
            {
                throw common::exception::TraceableException<std::runtime_error>(std::format("ERROR::SHADER::FILE_NOT_SUCCESSFULLY_READ\n{}", e.what()));
            }
        }
    };
}

================================================================================
Contenu du fichier './include/graphic/opengl/pipeline/component/uniform/Setter.hpp':
// file: Setter

#pragma once

#include <GL/glew.h>
#include <string>
#include <memory>
#include <glm/glm.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <graphic/opengl/context/UniformContext.hpp>

#include <graphic/Api.hpp>

namespace cenpy::graphic::opengl::pipeline
{
    namespace component::uniform
    {

        template <typename U>
        struct OpenGLUniformSetter
        {
            static constexpr GLenum glType = GL_INVALID_ENUM;
        };
        /**
         * @brief Specialization for GLfloat with corresponding setter
         */
        template <>
        struct OpenGLUniformSetter<GLfloat>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniform1f(uniform->getUniformID(), uniform->getValue<GLfloat>());
            }

            static constexpr GLenum glType = GL_FLOAT;
        };

        /**
         * @brief Specialization for GLint with corresponding setter
         */
        template <>
        struct OpenGLUniformSetter<GLint>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniform1i(uniform->getUniformID(), uniform->getValue<GLint>());
            }

            static constexpr GLenum glType = GL_INT;
        };

        /**
         * @brief Specialization for GLuint with corresponding setter
         */
        template <>
        struct OpenGLUniformSetter<GLuint>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniform1ui(uniform->getUniformID(), uniform->getValue<GLuint>());
            }

            static constexpr GLenum glType = GL_UNSIGNED_INT;
        };

        /**
         * @brief Specialization for GLdouble with corresponding setter
         */
        template <>
        struct OpenGLUniformSetter<GLdouble>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniform1d(uniform->getUniformID(), uniform->getValue<GLdouble>());
            }

            static constexpr GLenum glType = GL_DOUBLE;
        };

        /**
         * @brief Specialization for glm::vec2 with corresponding setter
         */
        template <>
        struct OpenGLUniformSetter<glm::vec2>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniform2fv(uniform->getUniformID(), uniform->getGLSize(), &uniform->getValue<glm::vec2>()[0]);
            }

            static constexpr GLenum glType = GL_FLOAT_VEC2;
        };

        /**
         * @brief Specialization for glm::vec3 with corresponding setter
         */
        template <>
        struct OpenGLUniformSetter<glm::vec3>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniform3fv(uniform->getUniformID(), uniform->getGLSize(), &uniform->getValue<glm::vec3>()[0]);
            }

            static constexpr GLenum glType = GL_FLOAT_VEC3;
        };

        /**
         * @brief Specialization for glm::vec4 with corresponding setter
         */
        template <>
        struct OpenGLUniformSetter<glm::vec4>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniform4fv(uniform->getUniformID(), uniform->getGLSize(), &uniform->getValue<glm::vec4>()[0]);
            }

            static constexpr GLenum glType = GL_FLOAT_VEC4;
        };

        /**
         * @brief Specialization for glm::dvec2 with corresponding setter
         */
        template <>
        struct OpenGLUniformSetter<glm::dvec2>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniform2dv(uniform->getUniformID(), uniform->getGLSize(), &uniform->getValue<glm::dvec2>()[0]);
            };

            static constexpr GLenum glType = GL_DOUBLE_VEC2;
        };

        /**
         * @brief Specialization for glm::dvec3 with corresponding setter
         */
        template <>
        struct OpenGLUniformSetter<glm::dvec3>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniform3dv(uniform->getUniformID(), uniform->getGLSize(), &uniform->getValue<glm::dvec3>()[0]);
            };

            static constexpr GLenum glType = GL_DOUBLE_VEC3;
        };

        /**
         * @brief Specialization for glm::dvec4 with corresponding setter
         */
        template <>
        struct OpenGLUniformSetter<glm::dvec4>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniform4dv(uniform->getUniformID(), uniform->getGLSize(), &uniform->getValue<glm::dvec4>()[0]);
            };

            static constexpr GLenum glType = GL_DOUBLE_VEC4;
        };

        // Specialization for glm::ivec2
        template <>
        struct OpenGLUniformSetter<glm::ivec2>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniform2iv(uniform->getUniformID(), uniform->getGLSize(), glm::value_ptr(uniform->getValue<glm::ivec2>()));
            }

            static constexpr GLenum glType = GL_INT_VEC2;
        };

        // Specialization for glm::ivec3
        template <>
        struct OpenGLUniformSetter<glm::ivec3>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniform3iv(uniform->getUniformID(), uniform->getGLSize(), glm::value_ptr(uniform->getValue<glm::ivec3>()));
            }

            static constexpr GLenum glType = GL_INT_VEC3;
        };

        // Specialization for glm::ivec4
        template <>
        struct OpenGLUniformSetter<glm::ivec4>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniform4iv(uniform->getUniformID(), uniform->getGLSize(), glm::value_ptr(uniform->getValue<glm::ivec4>()));
            }

            static constexpr GLenum glType = GL_INT_VEC4;
        };

        // Specialization for glm::uvec2 (unsigned int vector)
        template <>
        struct OpenGLUniformSetter<glm::uvec2>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniform2uiv(uniform->getUniformID(), uniform->getGLSize(), glm::value_ptr(uniform->getValue<glm::uvec2>()));
            }

            static constexpr GLenum glType = GL_UNSIGNED_INT_VEC2;
        };

        // Specialization for glm::uvec3 (unsigned int vector)
        template <>
        struct OpenGLUniformSetter<glm::uvec3>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniform3uiv(uniform->getUniformID(), uniform->getGLSize(), glm::value_ptr(uniform->getValue<glm::uvec3>()));
            }

            static constexpr GLenum glType = GL_UNSIGNED_INT_VEC3;
        };

        // Specialization for glm::uvec4 (unsigned int vector)
        template <>
        struct OpenGLUniformSetter<glm::uvec4>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniform4uiv(uniform->getUniformID(), uniform->getGLSize(), glm::value_ptr(uniform->getValue<glm::uvec4>()));
            }

            static constexpr GLenum glType = GL_UNSIGNED_INT_VEC4;
        };

        // Specialization for glm::mat2
        template <>
        struct OpenGLUniformSetter<glm::mat2>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniformMatrix2fv(uniform->getUniformID(), uniform->getGLSize(), GL_FALSE, glm::value_ptr(uniform->getValue<glm::mat2>()));
            }

            static constexpr GLenum glType = GL_FLOAT_MAT2;
        };

        // Specialization for glm::mat3
        template <>
        struct OpenGLUniformSetter<glm::mat3>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniformMatrix3fv(uniform->getUniformID(), uniform->getGLSize(), GL_FALSE, glm::value_ptr(uniform->getValue<glm::mat3>()));
            }

            static constexpr GLenum glType = GL_FLOAT_MAT3;
        };

        // Specialization for glm::mat4
        template <>
        struct OpenGLUniformSetter<glm::mat4>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniformMatrix4fv(uniform->getUniformID(), uniform->getGLSize(), GL_FALSE, glm::value_ptr(uniform->getValue<glm::mat4>()));
            }

            static constexpr GLenum glType = GL_FLOAT_MAT4;
        };

        // Specialization for glm::mat2x3
        template <>
        struct OpenGLUniformSetter<glm::mat2x3>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniformMatrix2x3fv(uniform->getUniformID(), uniform->getGLSize(), GL_FALSE, glm::value_ptr(uniform->getValue<glm::mat2x3>()));
            }

            static constexpr GLenum glType = GL_FLOAT_MAT2x3;
        };

        // Specialization for glm::mat3x2
        template <>
        struct OpenGLUniformSetter<glm::mat3x2>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniformMatrix3x2fv(uniform->getUniformID(), uniform->getGLSize(), GL_FALSE, glm::value_ptr(uniform->getValue<glm::mat3x2>()));
            }

            static constexpr GLenum glType = GL_FLOAT_MAT3x2;
        };

        // Specialization for glm::mat2x4
        template <>
        struct OpenGLUniformSetter<glm::mat2x4>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniformMatrix2x4fv(uniform->getUniformID(), uniform->getGLSize(), GL_FALSE, glm::value_ptr(uniform->getValue<glm::mat2x4>()));
            }

            static constexpr GLenum glType = GL_FLOAT_MAT2x4;
        };

        // Specialization for glm::mat4x2
        template <>
        struct OpenGLUniformSetter<glm::mat4x2>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniformMatrix4x2fv(uniform->getUniformID(), uniform->getGLSize(), GL_FALSE, glm::value_ptr(uniform->getValue<glm::mat4x2>()));
            }

            static constexpr GLenum glType = GL_FLOAT_MAT4x2;
        };

        // Specialization for glm::mat3x4
        template <>
        struct OpenGLUniformSetter<glm::mat3x4>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniformMatrix3x4fv(uniform->getUniformID(), uniform->getGLSize(), GL_FALSE, glm::value_ptr(uniform->getValue<glm::mat3x4>()));
            }

            static constexpr GLenum glType = GL_FLOAT_MAT3x4;
        };

        // Specialization for glm::mat4x3
        template <>
        struct OpenGLUniformSetter<glm::mat4x3>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniformMatrix4x3fv(uniform->getUniformID(), uniform->getGLSize(), GL_FALSE, glm::value_ptr(uniform->getValue<glm::mat4x3>()));
            }

            static constexpr GLenum glType = GL_FLOAT_MAT4x3;
        };

        /**
         * @brief Specialization for glm::mat4 with corresponding setter
         */

        // Specialization for glm::dmat2
        template <>
        struct OpenGLUniformSetter<glm::dmat2>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniformMatrix2dv(uniform->getUniformID(), uniform->getGLSize(), GL_FALSE, glm::value_ptr(uniform->getValue<glm::dmat2>()));
            }

            static constexpr GLenum glType = GL_DOUBLE_MAT2;
        };

        // Specialization for glm::dmat3
        template <>
        struct OpenGLUniformSetter<glm::dmat3>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniformMatrix3dv(uniform->getUniformID(), uniform->getGLSize(), GL_FALSE, glm::value_ptr(uniform->getValue<glm::dmat3>()));
            }

            static constexpr GLenum glType = GL_DOUBLE_MAT3;
        };

        // Specialization for glm::dmat4
        template <>
        struct OpenGLUniformSetter<glm::dmat4>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniformMatrix4dv(uniform->getUniformID(), uniform->getGLSize(), GL_FALSE, glm::value_ptr(uniform->getValue<glm::dmat4>()));
            }

            static constexpr GLenum glType = GL_DOUBLE_MAT4;
        };

        // Specialization for glm::dmat2x3
        template <>
        struct OpenGLUniformSetter<glm::dmat2x3>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniformMatrix2x3dv(uniform->getUniformID(), uniform->getGLSize(), GL_FALSE, glm::value_ptr(uniform->getValue<glm::dmat2x3>()));
            }

            static constexpr GLenum glType = GL_DOUBLE_MAT2x3;
        };

        // Specialization for glm::dmat3x2
        template <>
        struct OpenGLUniformSetter<glm::dmat3x2>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniformMatrix3x2dv(uniform->getUniformID(), uniform->getGLSize(), GL_FALSE, glm::value_ptr(uniform->getValue<glm::dmat3x2>()));
            }

            static constexpr GLenum glType = GL_DOUBLE_MAT3x2;
        };

        // Specialization for glm::dmat2x4
        template <>
        struct OpenGLUniformSetter<glm::dmat2x4>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniformMatrix2x4dv(uniform->getUniformID(), uniform->getGLSize(), GL_FALSE, glm::value_ptr(uniform->getValue<glm::dmat2x4>()));
            }

            static constexpr GLenum glType = GL_DOUBLE_MAT2x4;
        };

        // Specialization for glm::dmat4x2
        template <>
        struct OpenGLUniformSetter<glm::dmat4x2>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniformMatrix4x2dv(uniform->getUniformID(), uniform->getGLSize(), GL_FALSE, glm::value_ptr(uniform->getValue<glm::dmat4x2>()));
            }

            static constexpr GLenum glType = GL_DOUBLE_MAT4x2;
        };

        // Specialization for glm::dmat3x4
        template <>
        struct OpenGLUniformSetter<glm::dmat3x4>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniformMatrix3x4dv(uniform->getUniformID(), uniform->getGLSize(), GL_FALSE, glm::value_ptr(uniform->getValue<glm::dmat3x4>()));
            }

            static constexpr GLenum glType = GL_DOUBLE_MAT3x4;
        };

        // Specialization for glm::dmat4x3
        template <>
        struct OpenGLUniformSetter<glm::dmat4x3>
        {
            static void on(std::shared_ptr<cenpy::graphic::opengl::context::OpenGLUniformContext> uniform)
            {
                glUniformMatrix4x3dv(uniform->getUniformID(), uniform->getGLSize(), GL_FALSE, glm::value_ptr(uniform->getValue<glm::dmat4x3>()));
            }

            static constexpr GLenum glType = GL_DOUBLE_MAT4x3;
        };

    }
}
================================================================================
Contenu du fichier './include/graphic/opengl/profile/Attribute.hpp':
#pragma once

namespace cenpy::graphic::opengl::profile
{
    enum class Attribute
    {
        Classic
    };
}
================================================================================
Contenu du fichier './include/graphic/opengl/profile/Classic.hpp':
#pragma once

#include <graphic/opengl/profile/Pipeline.hpp>
#include <graphic/opengl/profile/Pass.hpp>
#include <graphic/opengl/profile/Shader.hpp>
#include <graphic/opengl/profile/Attribute.hpp>


namespace cenpy::graphic::opengl::profile
{
    class Classic
    {
    public:
        using Pipeline = Pipeline::Classic;
        using IPass = IPass::Classic;
        using Shader = Shader::Classic;
        using Attribute = Attribute::Classic;
        using Uniform = Uniform::Classic;
    }
}

================================================================================
Contenu du fichier './include/graphic/opengl/profile/Pass.hpp':
#pragma once

namespace cenpy::graphic::opengl::profile
{
    enum class Pass
    {
        Classic
    };
}
================================================================================
Contenu du fichier './include/graphic/opengl/profile/Pipeline.hpp':
#pragma once

namespace cenpy::graphic::opengl::profile
{
    enum class Pipeline
    {
        Classic
    };
}
================================================================================
Contenu du fichier './include/graphic/opengl/profile/Shader.hpp':
#pragma once

namespace cenpy::graphic::opengl::profile
{
    enum class Shader
    {
        Classic
    };
}
================================================================================
Contenu du fichier './include/graphic/opengl/profile/Uniform.hpp':
#pragma once

namespace cenpy::graphic::opengl::profile
{
    enum class Uniform
    {
        Classic
    };
}
================================================================================
Contenu du fichier './include/graphic/opengl/validator/AttributeConcept.hpp':
#pragma once
#include <memory>
#include <type_traits>
#include <graphic/validator/ComponentConcept.hpp>

namespace cenpy::graphic::opengl::validator
{
    using cenpy::graphic::validator::HasComponent;
    using cenpy::graphic::validator::HasOnMethod;

    template <typename API, auto PROFILE>
    concept OpenGLAttributeFlow = requires {
        requires HasComponent<typename API::AttributeContext::Binder<PROFILE>>;
        requires HasComponent<typename API::AttributeContext::Unbinder<PROFILE>>;
        requires HasComponent<typename API::AttributeContext::template Setter<int>>;

        requires HasOnMethod<typename API::AttributeContext::Binder<PROFILE>, typename API::AttributeContext>;
        requires HasOnMethod<typename API::AttributeContext::Unbinder<PROFILE>, typename API::AttributeContext>;
        requires HasOnMethod<typename API::AttributeContext::template Setter<int>, typename API::AttributeContext>;
    };
}
================================================================================
Contenu du fichier './include/graphic/opengl/validator/PassConcept.hpp':
#pragma once
#include <memory>
#include <type_traits>
#include <graphic/validator/ComponentConcept.hpp>

namespace cenpy::graphic::opengl::validator
{

    using cenpy::graphic::validator::HasComponent;
    using cenpy::graphic::validator::HasOnMethod;

    template <typename API, auto PROFILE>
    concept OpenGLPassFlow = requires {
        requires HasComponent<typename API::PassContext::Loader<PROFILE>>;
        requires HasComponent<typename API::PassContext::Freer<PROFILE>>;
        requires HasComponent<typename API::PassContext::ShaderAttacher<PROFILE>>;
        requires HasComponent<typename API::PassContext::AttributeReader<PROFILE>>;
        requires HasComponent<typename API::PassContext::User<PROFILE>>;

        requires HasOnMethod<typename API::PassContext::Loader<PROFILE>, typename API::PassContext>;
        requires HasOnMethod<typename API::PassContext::Freer<PROFILE>, typename API::PassContext>;
        requires HasOnMethod<typename API::PassContext::ShaderAttacher<PROFILE>, typename API::PassContext>;
        requires HasOnMethod<typename API::PassContext::AttributeReader<PROFILE>, typename API::PassContext>;
        requires HasOnMethod<typename API::PassContext::User<PROFILE>, typename API::PassContext>;
    };
}
================================================================================
Contenu du fichier './include/graphic/opengl/validator/PipelineConcept.hpp':
#pragma once
#include <memory>
#include <type_traits>
#include <graphic/validator/ComponentConcept.hpp>

namespace cenpy::graphic::opengl::validator
{
    using cenpy::graphic::validator::HasComponent;
    using cenpy::graphic::validator::HasOnMethod;

    template <typename API, auto PROFILE>
    concept OpenGLPipelineFlow = requires {
        requires HasComponent<typename API::PipelineContext::Resetter<PROFILE>>;
        requires HasComponent<typename API::PipelineContext::User<PROFILE>>;

        requires HasOnMethod<typename API::PipelineContext::Resetter<PROFILE>, typename API::PipelineContext>;
        requires HasOnMethod<typename API::PipelineContext::User<PROFILE>, typename API::PipelineContext>;
    };
}
================================================================================
Contenu du fichier './include/graphic/opengl/validator/ShaderConcept.hpp':
#pragma once
#include <memory>
#include <type_traits>
#include <graphic/validator/ComponentConcept.hpp>

namespace cenpy::graphic::opengl::validator
{
    using cenpy::graphic::validator::HasComponent;
    using cenpy::graphic::validator::HasOnMethod;

    template <typename API, auto PROFILE>
    concept OpenGLShaderFlow = requires {
        requires HasComponent<typename API::ShaderContext::Loader<PROFILE>>;
        requires HasComponent<typename API::ShaderContext::Freer<PROFILE>>;
        requires HasComponent<typename API::ShaderContext::Reader<PROFILE>>;

        requires HasOnMethod<typename API::ShaderContext::Loader<PROFILE>, typename API::ShaderContext>;
        requires HasOnMethod<typename API::ShaderContext::Freer<PROFILE>, typename API::ShaderContext>;
        requires HasOnMethod<typename API::ShaderContext::Reader<PROFILE>, typename API::ShaderContext>;
    };
}
================================================================================
Contenu du fichier './include/graphic/opengl/validator/UniformConcept.hpp':
#pragma once
#include <memory>
#include <type_traits>
#include <graphic/validator/ComponentConcept.hpp>

namespace cenpy::graphic::opengl::validator
{
    using cenpy::graphic::validator::HasComponent;
    using cenpy::graphic::validator::HasOnMethod;

    template <typename API>
    concept OpenGLUniformFlow = requires {
        requires HasComponent<typename API::UniformContext::template Setter<int>>;

        requires HasOnMethod<typename API::UniformContext::template Setter<int>, typename API::UniformContext>;
    };
}
================================================================================
Contenu du fichier './include/graphic/opengl/validator/Validator.hpp':
#pragma once
#include <graphic/opengl/validator/PassConcept.hpp>
#include <graphic/opengl/validator/PipelineConcept.hpp>
#include <graphic/opengl/validator/ShaderConcept.hpp>
#include <graphic/opengl/validator/AttributeConcept.hpp>
#include <graphic/opengl/validator/UniformConcept.hpp>

namespace cenpy::graphic::opengl::validator
{

    struct Validator
    {
    public:
        template <typename API, auto PROFILE>
            requires OpenGLPassFlow<API, PROFILE>
        static constexpr bool validatePass()
        {
            return true;
        }

        template <typename API, auto PROFILE>
            requires OpenGLPipelineFlow<API, PROFILE>
        static constexpr bool validatePipeline()
        {
            return true;
        }
        template <typename API, auto PROFILE>
            requires OpenGLShaderFlow<API, PROFILE>
        static constexpr bool validateShader()
        {
            return true;
        }
        template <typename API, auto PROFILE>
            requires OpenGLAttributeFlow<API, PROFILE>
        static constexpr bool validateAttribute()
        {
            return true;
        }
        template <typename API>
            requires OpenGLUniformFlow<API>
        static constexpr bool validateUniform()
        {
            return true;
        }
    };
}
================================================================================
Contenu du fichier './include/graphic/pipeline/Attribute.hpp':
#pragma once

#include <memory>
#include <graphic/Api.hpp>
#include <graphic/context/AttributeContext.hpp>
#include <graphic/validator/ComponentConcept.hpp>

namespace cenpy::graphic::pipeline
{

    template <typename API>
    class IAttribute
    {
    public:
        // Constructor
        explicit IAttribute(std::shared_ptr<typename API::AttributeContext> context)
            : m_context(context) {}

        IAttribute() : IAttribute(std::make_shared<typename API::AttributeContext>())
        {
        }

        void bind()
        {
            bind(m_context);
        }

        template <typename T>
        void set(std::shared_ptr<T> value)
        {
            m_context->template setValue<T>(value);

            if constexpr (graphic::validator::HasComponent<typename API::AttributeContext::Setter<std::shared_ptr<int>>>)
            {
                API::AttributeContext::template Setter<std::shared_ptr<int>>::on(m_context);
            }
            else
            {
                throw common::exception::TraceableException<std::runtime_error>("ERROR::ATTRIBUTE::UNSUPPORTED_TYPE");
            }
        }

        void unbind()
        {
            unbind(m_context);
        }

        [[nodiscard]] virtual std::shared_ptr<typename API::AttributeContext> getContext() const
        {
            return m_context;
        }

    protected:
        virtual void unbind(std::shared_ptr<typename API::AttributeContext> context) = 0;
        virtual void bind(std::shared_ptr<typename API::AttributeContext> context) = 0;

    private:
        std::shared_ptr<typename API::AttributeContext> m_context;
    };

    template <typename API, auto PROFILE>
        requires(API::Validator::template validateAttribute<API, PROFILE>())
    class Attribute : public IAttribute<API>
    {
    public:
        using IAttribute<API>::IAttribute;
        using IAttribute<API>::bind;
        using IAttribute<API>::unbind;
        using IAttribute<API>::set;

    protected:
        void bind(std::shared_ptr<typename API::AttributeContext> context) override
        {
            if constexpr (graphic::validator::HasComponent<typename API::AttributeContext::Binder<PROFILE>>)
            {
                API::AttributeContext::template Binder<PROFILE>::on(context);
            }
        }

        void unbind(std::shared_ptr<typename API::AttributeContext> context) override
        {
            if constexpr (graphic::validator::HasComponent<typename API::AttributeContext::Unbinder<PROFILE>>)
            {
                API::AttributeContext::template Unbinder<PROFILE>::on(context);
            }
        }
    };
}

================================================================================
Contenu du fichier './include/graphic/pipeline/Pass.hpp':
/**
 * @file IPass.hpp
 * @brief Defines the interface and OpenGL implementation for shader passes in a multi-pass rendering system.
 *
 * This file introduces the concept of a 'IPass', representing a sequence of shader operations in a rendering pipeline.
 * It includes the abstract IPass class template and its OpenGL specialization. The design is flexible to support
 * other graphics APIs such as Vulkan, DirectX, and Metal under respective namespaces.
 * The 'IPass' is an integral part of the multipass shader system.
 *
 * @author Djoé DENNE
 * @date 13/12/2023
 */

#pragma once

#include <GL/glew.h>
#include <vector>
#include <string>
#include <format>
#include <type_traits>
#include <unordered_map>
#include <memory>
#include <utils.hpp>
#include <common/exception/TraceableException.hpp>
#include <graphic/pipeline/Shader.hpp>
#include <graphic/pipeline/Uniform.hpp>
#include <graphic/pipeline/Attribute.hpp>
#include <graphic/context/PassContext.hpp>
#include <graphic/validator/ComponentConcept.hpp>

namespace cenpy::graphic::pipeline
{
    template <typename API>
    class IPass
    {
    public:
        // New or modified methods

        // Constructor accepting components
        IPass(const std::initializer_list<std::shared_ptr<IShader<API>>> &shaders,
              std::shared_ptr<typename API::PassContext> context) : m_context(context)
        {
            for (auto &shader : shaders)
            {
                m_context->addShader(shader);
            }
        }

        explicit IPass(const std::initializer_list<std::shared_ptr<IShader<API>>> shaders)
            : IPass(shaders,
                    std::make_shared<typename API::PassContext>())
        {
        }

        virtual void load()
        {
            for (auto &shader : m_context->getShaders())
            {
                shader->load();
            }
            load(m_context);
            readUniforms(m_context);
            readAttributes(m_context);
        }

        virtual void use()
        {
            use(m_context);
        }

        virtual void free()
        {
            free(m_context);
        }

        /**
         * @brief Adds a uniform with the specified name and value to the pass.
         *
         * @tparam T The type of the uniform value.
         * @param name The name of the uniform.
         * @param value The value of the uniform.
         * @return A reference to the IPass object.
         * @throws std::runtime_error if the uniform is not found.
         */
        template <typename T>
        std::shared_ptr<IPass<API>> withUniform(const std::string &name, const T &value)
        {
            if (auto uniform = m_context->getUniform(name))
            {
                uniform->template set<T>(value);
                return shared();
            }
            throw common::exception::TraceableException<std::runtime_error>(std::format("ERROR::SHADER::UNIFORM_NOT_FOUND\nUniform {} not found", name));
        }

        /**
         * @brief Returns a const reference to the map of uniforms in the pass.
         *
         * @return A const reference to the map of uniforms.
         */
        [[nodiscard]] virtual const std::unordered_map<std::string, std::shared_ptr<Uniform<API>>, collection_utils::StringHash, collection_utils::StringEqual> &getUniforms() const
        {
            return m_context->getUniforms();
        }

        /**
         * @brief Returns a const reference to the map of attributes in the pass.
         *
         * @return A const reference to the map of attributes.
         */
        [[nodiscard]] virtual const std::unordered_map<std::string, std::shared_ptr<IAttribute<API>>, collection_utils::StringHash, collection_utils::StringEqual> &getAttributes() const
        {
            return m_context->getAttributes();
        }

        /**
         * @brief Returns a const reference to the vector of shaders in the pass.
         *
         * @return A const reference to the vector of shaders.
         */
        [[nodiscard]] virtual const std::vector<std::shared_ptr<IShader<API>>> &getShaders() const
        {
            return m_context->getShaders();
        }

        /**
         * @brief Returns the pass context.
         * @return The pass context.
         */
        [[nodiscard]] virtual std::shared_ptr<typename API::PassContext> getContext() const
        {
            return m_context;
        }

    protected:
        virtual void load(std::shared_ptr<typename API::PassContext> context) = 0;
        virtual void readUniforms(std::shared_ptr<typename API::PassContext> context) = 0;
        virtual void readAttributes(std::shared_ptr<typename API::PassContext> context) = 0;
        virtual void free(std::shared_ptr<typename API::PassContext> context) = 0;
        virtual void use(std::shared_ptr<typename API::PassContext> context) = 0;
        virtual std::shared_ptr<IPass<API>> shared() const = 0;

    private:
        std::shared_ptr<typename API::PassContext> m_context; ///< The pass context.
    };

    template <typename API, auto PROFILE>
        requires(API::Validator::template validatePass<API, PROFILE>())
    class Pass : public IPass<API>
    {
    public:
        using IPass<API>::IPass;
        using IPass<API>::load;
        using IPass<API>::free;
        using IPass<API>::use;

        virtual ~Pass()
        {
            try
            {
                free();
            }
            catch (const std::exception &e)
            {
                std::cerr << e.what() << std::endl;
            }
        }

    protected:
        void load(std::shared_ptr<typename API::PassContext> context) override
        {
            if constexpr (graphic::validator::HasComponent<typename API::PassContext::Loader<PROFILE>>)
            {
                API::PassContext::template Loader<PROFILE>::on(context);
            }
        }

        void readUniforms(std::shared_ptr<typename API::PassContext> context) override
        {
            if constexpr (graphic::validator::HasComponent<typename API::PassContext::UniformReader<PROFILE>>)
            {
                API::PassContext::template UniformReader<PROFILE>::on(context);
            }
        }

        void readAttributes(std::shared_ptr<typename API::PassContext> context) override
        {
            if constexpr (graphic::validator::HasComponent<typename API::PassContext::AttributeReader<PROFILE>>)
            {
                API::PassContext::template AttributeReader<PROFILE>::on(context);
            }
        }

        void free(std::shared_ptr<typename API::PassContext> context) override
        {
            if constexpr (graphic::validator::HasComponent<typename API::PassContext::Freer<PROFILE>>)
            {
                API::PassContext::template Freer<PROFILE>::on(context);
            }
        }

        void use(std::shared_ptr<typename API::PassContext> context) override
        {
            if constexpr (graphic::validator::HasComponent<typename API::PassContext::User<PROFILE>>)
            {
                API::PassContext::template User<PROFILE>::on(context);
            }
        }

        std::shared_ptr<IPass<API>> shared() const override
        {
            return std::make_shared<Pass<API, PROFILE>>(*this);
        }
    };
} // namespace cenpy::graphic::pipeline
================================================================================
Contenu du fichier './include/graphic/pipeline/Pipeline.hpp':
#pragma once

#include <vector>
#include <string>
#include <format>
#include <iostream>
#include <unordered_map>
#include <memory>
#include <utils.hpp>
#include <common/exception/TraceableException.hpp>
#include <graphic/pipeline/Pass.hpp>
#include <graphic/context/PipelineContext.hpp>
#include <graphic/validator/ComponentConcept.hpp>

namespace cenpy::graphic::pipeline
{
    template <typename API>
    class IPipeline
    {
    public:
        IPipeline(const std::initializer_list<std::shared_ptr<IPass<API>>> &passes,
                  std::shared_ptr<typename API::PipelineContext> context)
            : m_context(context)
        {
            for (auto &pass : passes)
            {
                m_context->addPass(pass);
            }
        }

        explicit IPipeline(const std::initializer_list<std::shared_ptr<IPass<API>>> &passes) : IPipeline(passes,
                                                                                                         std::make_shared<typename API::PipelineContext>())
        {
        }

        [[nodiscard]] std::shared_ptr<IPass<API>> forPass(const int &pass)
        {
            return m_context->getPass(pass);
        }

        [[nodiscard]] virtual int getPassesCount() const
        {
            return m_context->getPassesCount();
        }

        [[nodiscard]] bool hasNext() const
        {
            return m_context->getCurrentPass() + 1 < getPassesCount();
        }

        virtual bool useNext()
        {
            if (hasNext())
            {
                use(m_context->getCurrentPass() + 1);
                return hasNext();
            }
            reset();
            return false;
        }

        virtual void use(const int &pass)
        {
            m_context->setCurrentPass(pass);
            use(m_context);
        }

        /**
         * @brief Resets the pipeline to its initial state. unset pipeline in OpenGL context.
         */
        virtual void reset()
        {
            reset(m_context);
        }

        [[nodiscard]] virtual std::shared_ptr<typename API::PipelineContext> getContext() const
        {
            return m_context;
        }

    protected:
        virtual void use(std::shared_ptr<typename API::PipelineContext> context) = 0;
        virtual void reset(std::shared_ptr<typename API::PipelineContext> context) = 0;

    private:
        std::shared_ptr<typename API::PipelineContext> m_context;
    };

    template <typename API, auto PROFILE>
        requires(API::Validator::template validatePipeline<API, PROFILE>())
    class Pipeline : public IPipeline<API>
    {
    public:
        using IPipeline<API>::IPipeline;
        using IPipeline<API>::use;
        using IPipeline<API>::reset;

    protected:
        void use(std::shared_ptr<typename API::PipelineContext> context) override
        {
            if constexpr (graphic::validator::HasComponent<typename API::PipelineContext::User<PROFILE>>)
            {
                API::PipelineContext::template User<PROFILE>::on(context);
            }
        }

        void reset(std::shared_ptr<typename API::PipelineContext> context) override
        {
            if constexpr (graphic::validator::HasComponent<typename API::PipelineContext::Resetter<PROFILE>>)
            {
                API::PipelineContext::template Resetter<PROFILE>::on(context);
            }
        }
    };

} // namespace cenpy::graphic::pipeline
================================================================================
Contenu du fichier './include/graphic/pipeline/Shader.hpp':
/**
 * @file Shader.hpp
 * @brief Defines the shader interface and OpenGL implementation for shader objects.
 *
 * This file contains the abstract definition of a shader object and its OpenGL-specific implementation.
 * The shader system is designed to be adaptable for multiple graphics APIs, including Vulkan, DirectX, and Metal.
 * The current implementation under the 'cenpy::graphic::pipeline::opengl' namespace is tailored for OpenGL.
 *
 * @author Djoé DENNE
 * @date 13/12/2023
 */

#pragma once

#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <memory>
#include <string>
#include <format>
#include <fstream>
#include <common/exception/TraceableException.hpp>
#include <graphic/context/ShaderContext.hpp>
#include <graphic/validator/ComponentConcept.hpp>

namespace cenpy::graphic::pipeline
{
    /**
     * @class Shader
     * @brief Represents the base class for a shader, managing its lifecycle using composition.
     *
     * The Shader class abstracts the shader object, managing its loading, operation, and cleanup.
     * It delegates shader-specific operations to specialized components and maintains its own ShaderContext,
     * which encapsulates all necessary state and API-specific details.
     *
     *
     * @tparam API The graphics API context type to be used. This API class must define
     *             ShaderContext, Loader, and Freer types within its scope. These types
     *             correspond to the specific implementations for the chosen graphics API.
     *             For example, if using OpenGL, the API class should define the respective
     *             OpenGL context, loader, and freer.
     *
     * Design Considerations:
     * - Composition over Inheritance: The class uses separate components for loading and freeing shader resources.
     * - Encapsulation: It encapsulates shader operations and context, providing a clear and unified interface.
     * - Resource Management: Utilizes smart pointers for automatic resource management and safer code.
     */
    template <typename API>
    class IShader
    {
    public:
        /**
         * @brief Constructor for Shader.
         * @param shaderPath Path to the shader source file.
         * @param shaderType Type of the shader (e.g., vertex, fragment).
         * @param loader Unique pointer to the shader loader component.
         * @param freer Unique pointer to the shader freer component.
         * @param context Unique pointer to the ShaderContext, managing API-specific shader details.
         */
        IShader(const std::string &shaderPath, context::ShaderType shaderType,
                std::shared_ptr<typename API::ShaderContext> context) : m_context(context)
        {
            m_context->setShaderType(shaderType);
            m_context->setShaderPath(shaderPath);
            // Implementation to read shader code from file can be added here
        }

        /**
         * @brief Templated constructor for creating a shader with an API-specific context.
         *
         * This constructor template allows for the automatic creation and setup of an API-specific
         * shader context, loader, and freer. It's designed to simplify the instantiation process
         * by inferring the required components based on the provided API template parameter.
         *
         * @param shaderPath Path to the shader source file. This path is used to read the shader
         *                   code from the file system.
         * @param shaderType The type of the shader (e.g., vertex, fragment). This information is
         *                   used by the shader context and loader for appropriate handling.
         *
         * Example Usage:
         *   Shader<OpenGL> myShader("vertex_shader.glsl", ShaderType::VERTEX);
         * This line creates a shader object for OpenGL, automatically setting up the OpenGL
         * shader context, loader, and freer.
         */
        IShader(const std::string &shaderPath, context::ShaderType shaderType)
            : IShader(shaderPath, shaderType,
                      std::make_shared<typename API::ShaderContext>())
        {
        }

        /**
         * @brief Get the shader Context.
         * @return The shader Context.
         */
        [[nodiscard]] virtual const std::shared_ptr<typename API::ShaderContext> &getContext() const
        {
            return m_context;
        }

        /**
         * @brief Loads the shader into the rendering system.
         */
        virtual void load()
        {
            if (m_context)
            {
                if (m_context->getShaderCode().empty())
                {
                    read(m_context);
                }
                load(m_context);
            }
        }

        /**
         * @brief Frees the shader resources.
         */
        virtual void free()
        {
            if (m_context)
            {
                free(m_context);
            }
        }

    protected:
        virtual void load(std::shared_ptr<typename API::ShaderContext> context) = 0;
        virtual void free(std::shared_ptr<typename API::ShaderContext> context) = 0;
        virtual void read(std::shared_ptr<typename API::ShaderContext> context) = 0;

    private:
        std::shared_ptr<typename API::ShaderContext> m_context; // API-specific shader context
    };

    template <typename API, auto PROFILE>
        requires(API::Validator::template validateShader<API, PROFILE>())
    class Shader : public IShader<API>
    {
    public:
        using IShader<API>::IShader;
        using IShader<API>::load;
        using IShader<API>::free;

        ~Shader()
        {
            free();
        }

    protected:
        void free(std::shared_ptr<typename API::ShaderContext> context) override
        {
            if constexpr (graphic::validator::HasComponent<typename API::ShaderContext::template Freer<PROFILE>>)
            {
                API::ShaderContext::template Freer<PROFILE>::on(context);
            }
        }

        void load(std::shared_ptr<typename API::ShaderContext> context) override
        {
            if constexpr (graphic::validator::HasComponent<typename API::ShaderContext::template Loader<PROFILE>>)
            {
                API::ShaderContext::template Loader<PROFILE>::on(context);
            }
        }

        void read(std::shared_ptr<typename API::ShaderContext> context) override
        {
            if constexpr (graphic::validator::HasComponent<typename API::ShaderContext::template Reader<PROFILE>>)
            {
                API::ShaderContext::template Reader<PROFILE>::on(context);
            }
        }
    };
} // namespace cenpy::graphic::pipeline
================================================================================
Contenu du fichier './include/graphic/pipeline/Uniform.hpp':
/**
 * @file uniform.hpp
 * @brief Defines classes and templates for managing shader uniform variables across various graphics APIs.
 *
 * The uniform management system is designed to be flexible and extensible to support multiple graphics APIs
 * such as OpenGL, Vulkan, DirectX, and Metal. This file contains the Uniform class, which serves as an
 * abstract foundation, and various template specializations and type traits for handling different uniform types.
 *
 * @author Djoé DENNE
 * @date 13/12/2023
 */

#pragma once

#include <type_traits>
#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <string>
#include <format>
#include <any>
#include <unordered_map>
#include <glm/glm.hpp>
#include <graphic/context/UniformContext.hpp>
#include <graphic/validator/ComponentConcept.hpp>
#include <common/exception/TraceableException.hpp>

#include <graphic/opengl/pipeline/component/uniform/Setter.hpp>
#include <graphic/opengl/validator/Validator.hpp>

namespace cenpy::graphic::pipeline
{
    /**
     * @class Uniform
     * @brief Abstract base class for representing uniform variables in shaders.
     *
     * This class provides a foundational interface for handling uniform variables.
     * It is designed to be extended by specific implementations for different graphics APIs
     * such as OpenGL, Vulkan, DirectX, and Metal. The class includes template methods for
     * setting and getting uniform values with type safety, enforced through specialized setters.
     */
    template <typename API>
        requires(API::Validator::template validateUniform<API>())
    class Uniform
    {
    public:
        explicit Uniform(std::shared_ptr<typename API::UniformContext> context) : m_context(context) {}

        Uniform() : Uniform(std::make_shared<typename API::UniformContext>())
        {
        }

        /**
         * @brief Sets the value of the uniform variable.
         *
         * This method is used to set the value of the uniform variable. It is implemented
         * by the API-specific Uniform class, which provides the necessary context for
         * setting the value.
         *
         * @param value The value to set the uniform variable to.
         */
        template <typename T>
        void set(const T &value)
        {
            if constexpr (graphic::validator::HasComponent<typename API::UniformContext::template Setter<T>>)
            {
                m_context->template setValue<T>(value);
                API::UniformContext::template Setter<T>::on(m_context);
            }
            else
            {
                throw common::exception::TraceableException<std::runtime_error>("ERROR::UNIFORM::UNSUPPORTED_TYPE");
            }
        }

        /**
         * @brief Gets the value of the uniform variable.
         *
         * This method is used to get the value of the uniform variable. It is implemented
         * by the API-specific Uniform class, which provides the necessary context for
         * getting the value.
         *
         * @return The value of the uniform variable.
         */
        template <typename T>
        const T &get() const
        {
            return m_context->template getValue<T>();
        }

        std::shared_ptr<typename API::UniformContext> getContext() const
        {
            return m_context;
        }

    private:
        std::shared_ptr<typename API::UniformContext> m_context; // API-specific shader context
    };

} // namespace cenpy::graphic::pipeline

================================================================================
Contenu du fichier './include/graphic/texture/Texture.hpp':
#pragma once

#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <iostream>
#include <vector>
#include <fstream>
#include <sstream>
#include <cmath>

class Texture
{
public:
    Texture(const char *imagePath)
    {
        glGenTextures(1, &textureID);
        glBindTexture(GL_TEXTURE_2D, textureID);

        int width, height, nrChannels;
        stbi_set_flip_vertically_on_load(true);
        unsigned char *data = stbi_load(imagePath, &width, &height, &nrChannels, 0);

        if (data)
        {
            GLenum format = (nrChannels == 3) ? GL_RGB : GL_RGBA;
            glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data);
            glGenerateMipmap(GL_TEXTURE_2D);
        }
        else
        {
            std::cerr << "Failed to load texture\n";
        }

        stbi_image_free(data);
    }

    void use() const
    {
        glBindTexture(GL_TEXTURE_2D, textureID);
    }

private:
    GLuint textureID;
};
================================================================================
Contenu du fichier './include/graphic/validator/ComponentConcept.hpp':
#pragma once

#include <memory>
#include <type_traits>

namespace cenpy::graphic::validator
{
    // Concept to check if a type has a static method do with the specified signature
    template <typename T, typename C>
    concept HasOnMethod = requires(std::shared_ptr<C> context) {
        {
            T::on(context)
        } -> std::same_as<void>;
    };

    template <typename C>
    concept HasComponent = requires {
        typename C;
    };
}
================================================================================
Contenu du fichier './tests/mock/graphic/MockApi.hpp':
// Api.hpp

#pragma once

namespace cenpy::graphic::opengl::validator
{
    struct Validator;
}
namespace cenpy::mock::graphic
{
    namespace opengl
    {
        namespace validator
        {
            using cenpy::graphic::opengl::validator::Validator;
        }

        namespace context
        {
            class MockShaderContext;
            class MockPassContext;
            class MockUniformContext;
            class MockAttributeContext;
            class MockPipelineContext;
        }
    }
    namespace api
    {
        /**
         * @class OpenGL
         * @brief Encapsulation of the OpenGL context configuration for shader management.
         *
         * The OpenGL class acts as a part of the configuration layer for the shader management system,
         * specifically tailored for the OpenGL graphics API. It defines the type of ShaderContext to
         * be used when working with OpenGL shaders. This class is utilized as a template parameter
         * in the Shader class to provide the necessary OpenGL-specific context, loaders, and freers.
         *
         * Usage:
         *   Shader<OpenGL> shader("path/to/shader", ShaderType::VERTEX);
         *
         * This approach allows for clear and concise configuration, making the shader system adaptable
         * to different graphics APIs by simply changing the template argument.
         */
        class MockOpenGL
        {
        public:
            using ShaderContext = graphic::opengl::context::MockShaderContext;
            using PassContext = graphic::opengl::context::MockPassContext;
            using UniformContext = graphic::opengl::context::MockUniformContext;
            using AttributeContext = graphic::opengl::context::MockAttributeContext;
            using PipelineContext = graphic::opengl::context::MockPipelineContext;
            using Validator = graphic::opengl::validator::Validator;
        };
    }
}
================================================================================
Contenu du fichier './tests/mock/graphic/opengl/context/MockAttributeContext.hpp':
// AttributeContext.hpp

#pragma once

#include <gmock/gmock.h>
#include <graphic/MockApi.hpp>
#include <graphic/opengl/context/AttributeContext.hpp>
#include <graphic/opengl/pipeline/component/attribute/MockBinder.hpp>
#include <graphic/opengl/pipeline/component/attribute/MockSetter.hpp>
#include <graphic/opengl/pipeline/component/attribute/MockUnbinder.hpp>

namespace cenpy::mock::graphic::opengl::context
{

    class MockAttributeContext : public cenpy::graphic::context::AttributeContext<graphic::api::MockOpenGL>
    {
    public:
        template <auto PROFILE>
        using Binder = opengl::pipeline::component::attribute::MockBinder<PROFILE>;
        template <typename A>
        using Setter = opengl::pipeline::component::attribute::MockSetter<A>;
        template <auto PROFILE>
        using Unbinder = opengl::pipeline::component::attribute::MockUnbinder<PROFILE>;

        MOCK_METHOD(void, setAttributeID, (GLuint attributeId), ());
        MOCK_METHOD(GLuint, getAttributeID, (), (const));
        MOCK_METHOD(void, setGLType, (GLenum type), ());
        MOCK_METHOD(GLenum, getGLType, (), (const));
        MOCK_METHOD(void, setSize, (GLuint size), ());
        MOCK_METHOD(GLuint, getGLSize, (), (const));
        MOCK_METHOD(void, setBufferID, (GLuint bufferId), ());
        MOCK_METHOD(GLuint, getBufferID, (), (const));
    };
}

================================================================================
Contenu du fichier './tests/mock/graphic/opengl/context/MockPassContext.hpp':
// PassContext.hpp

#pragma once

#include <graphic/MockApi.hpp>
#include <graphic/opengl/context/PassContext.hpp>
#include <graphic/opengl/context/MockAttributeContext.hpp>
#include <graphic/opengl/context/MockUniformContext.hpp>
#include <graphic/opengl/pipeline/component/pass/MockLoader.hpp>
#include <graphic/opengl/pipeline/component/pass/MockFreer.hpp>
#include <graphic/opengl/pipeline/component/pass/MockShaderAttacher.hpp>
#include <graphic/opengl/pipeline/component/pass/MockUniformReader.hpp>
#include <graphic/opengl/pipeline/component/pass/MockAttributeReader.hpp>
#include <graphic/opengl/pipeline/component/pass/MockUser.hpp>

namespace cenpy::mock::graphic::opengl::context
{

    class MockPassContext : public cenpy::graphic::context::PassContext<graphic::api::MockOpenGL>
    {
    public:
        template <auto PROFILE>
        using Loader = opengl::pipeline::component::pass::MockLoader<PROFILE>;
        template <auto PROFILE>
        using Freer = opengl::pipeline::component::pass::MockFreer<PROFILE>;
        template <auto PROFILE>
        using ShaderAttacher = opengl::pipeline::component::pass::MockShaderAttacher<PROFILE>;
        template <auto PROFILE>
        using UniformReader = opengl::pipeline::component::pass::MockUniformReader<PROFILE>;
        template <auto PROFILE>
        using AttributeReader = opengl::pipeline::component::pass::MockAttributeReader<PROFILE>;
        template <auto PROFILE>
        using User = opengl::pipeline::component::pass::MockUser<PROFILE>;
    };
}

================================================================================
Contenu du fichier './tests/mock/graphic/opengl/context/MockPipelineContext.hpp':
// PipelineContext.hpp

#pragma once

#include <graphic/MockApi.hpp>
#include <graphic/opengl/context/PipelineContext.hpp>
#include <graphic/opengl/pipeline/component/pipeline/MockUser.hpp>
#include <graphic/opengl/pipeline/component/pipeline/MockResetter.hpp>

namespace cenpy::mock::graphic::opengl::context
{

    class MockPipelineContext : public cenpy::graphic::context::PipelineContext<graphic::api::MockOpenGL>
    {
    public:
        template <auto PROFILE>
        using User = opengl::pipeline::component::pipeline::MockUser<PROFILE>;
        template <auto PROFILE>
        using Resetter = opengl::pipeline::component::pipeline::MockResetter<PROFILE>;
    };
}

================================================================================
Contenu du fichier './tests/mock/graphic/opengl/context/MockShaderContext.hpp':
// ShaderContext.hpp

#pragma once

#include <gmock/gmock.h>
#include <graphic/MockApi.hpp>
#include <graphic/opengl/context/ShaderContext.hpp>
#include <graphic/opengl/pipeline/component/shader/MockLoader.hpp>
#include <graphic/opengl/pipeline/component/shader/MockFreer.hpp>
#include <graphic/opengl/pipeline/component/shader/MockReader.hpp>

namespace cenpy::mock::graphic::opengl::context
{
    
    class MockShaderContext : public cenpy::graphic::context::ShaderContext<graphic::api::MockOpenGL>
    {
    public:
        template <auto PROFILE>
        using Loader = opengl::pipeline::component::shader::MockLoader< PROFILE>;
        template <auto PROFILE>
        using Freer = opengl::pipeline::component::shader::MockFreer< PROFILE>;
        template <auto PROFILE>
        using Reader = opengl::pipeline::component::shader::MockReader< PROFILE>;

        MOCK_METHOD(void, setShaderID, (GLuint shaderID), ());
        MOCK_METHOD(GLuint, getShaderID, (), (const));
        MOCK_METHOD(GLenum, getGLShaderType, (), (const));
        MOCK_METHOD(void, setShaderType, (cenpy::graphic::context::ShaderType shaderType), (override));
        MOCK_METHOD(cenpy::graphic::context::ShaderType, getShaderType, (), (const, override));
        MOCK_METHOD(void, setShaderPath, (const std::string &shaderPath), (override));
        MOCK_METHOD(const std::string &, getShaderPath, (), (const, override));
        MOCK_METHOD(void, setShaderCode, (const std::string &shaderCode), (override));
        MOCK_METHOD(const std::string &, getShaderCode, (), (const, override));
    };
}

================================================================================
Contenu du fichier './tests/mock/graphic/opengl/context/MockUniformContext.hpp':
// UniformContext.hpp

#pragma once

#include <gmock/gmock.h>
#include <graphic/MockApi.hpp>
#include <graphic/opengl/context/UniformContext.hpp>
#include <graphic/opengl/pipeline/component/uniform/MockSetter.hpp>

namespace cenpy::mock::graphic::opengl::context
{

    class MockUniformContext : public cenpy::graphic::context::UniformContext<graphic::api::MockOpenGL>
    {
    public:
        template <typename T>
        using Setter = opengl::pipeline::component::uniform::MockSetter<T>;

        MOCK_METHOD(void, setUniformID, (GLuint uniformId), ());
        MOCK_METHOD(GLuint, getUniformID, (), (const));
        MOCK_METHOD(void, setGLType, (GLenum type), ());
        MOCK_METHOD(GLenum, getGLType, (), (const));
        MOCK_METHOD(void, setSize, (GLuint size), ());
        MOCK_METHOD(GLuint, getGLSize, (), (const));
    };
}

================================================================================
Contenu du fichier './tests/mock/graphic/opengl/pipeline/component/attribute/MockBinder.hpp':
// file: Binder

#pragma once

#include <memory>
#include <gmock/gmock.h>
#include <graphic/MockApi.hpp>
#include <graphic/opengl/profile/Attribute.hpp>

namespace cenpy::mock::graphic::opengl::pipeline::component::attribute
{
    template <auto PROFILE>
    class MockBinder
    {
    public:
        static std::shared_ptr<MockBinder<PROFILE>> instance()
        {
            static auto instance = std::make_shared<MockBinder<PROFILE>>();
            return instance;
        }

        static void reset()
        {
            ::testing::Mock::VerifyAndClearExpectations(instance().get());
        }

        static void on(std::shared_ptr<graphic::api::MockOpenGL::AttributeContext> openglContext)
        {
            instance()->mockOn(openglContext);
        }

        MOCK_METHOD(void, mockOn, (std::shared_ptr<graphic::api::MockOpenGL::AttributeContext> attribute), ());
    };

}
================================================================================
Contenu du fichier './tests/mock/graphic/opengl/pipeline/component/attribute/MockSetter.hpp':
// file: Setter

#pragma once

#include <memory>
#include <gmock/gmock.h>
#include <graphic/MockApi.hpp>
#include <graphic/opengl/profile/Attribute.hpp>

namespace cenpy::mock::graphic::opengl::pipeline::component::attribute
{
    template <typename A>
    class MockSetter
    {
    public:
        static std::shared_ptr<MockSetter> instance()
        {
            static auto instance = std::make_shared<MockSetter>();
            return instance;
        }

        static void reset()
        {
            ::testing::Mock::VerifyAndClearExpectations(instance().get());
        }

        static void on(std::shared_ptr<graphic::api::MockOpenGL::AttributeContext> openglContext)
        {
            instance()->mockOn(openglContext);
        }

        MOCK_METHOD(void, mockOn, (std::shared_ptr<graphic::api::MockOpenGL::AttributeContext> attribute), ());
    };
}
================================================================================
Contenu du fichier './tests/mock/graphic/opengl/pipeline/component/attribute/MockUnbinder.hpp':
// file: Binder

#pragma once

#include <memory>
#include <gmock/gmock.h>
#include <graphic/MockApi.hpp>
#include <graphic/opengl/profile/Attribute.hpp>

namespace cenpy::mock::graphic::opengl::pipeline::component::attribute
{
    template <auto PROFILE>
    class MockUnbinder
    {
    public:
        static std::shared_ptr<MockUnbinder<PROFILE>> instance()
        {
            static auto instance = std::make_shared<MockUnbinder<PROFILE>>();
            return instance;
        }

        static void reset()
        {
            ::testing::Mock::VerifyAndClearExpectations(instance().get());
        }

        static void on(std::shared_ptr<graphic::api::MockOpenGL::AttributeContext> openglContext)
        {
            instance()->mockOn(openglContext);
        }
        MOCK_METHOD(void, mockOn, (std::shared_ptr<graphic::api::MockOpenGL::AttributeContext> attribute), ());
    };

}
================================================================================
Contenu du fichier './tests/mock/graphic/opengl/pipeline/component/pass/MockAttributeReader.hpp':
#pragma once

#include <memory>
#include <gmock/gmock.h>
#include <graphic/MockApi.hpp>
#include <graphic/opengl/profile/Pass.hpp>

namespace cenpy::mock::graphic::opengl::pipeline::component::pass
{
    template <auto PROFILE>
    class MockAttributeReader
    {
    public:
        static std::shared_ptr<MockAttributeReader<PROFILE>> instance()
        {
            static auto instance = std::make_shared<MockAttributeReader<PROFILE>>();
            return instance;
        }

        static void reset()
        {
            ::testing::Mock::VerifyAndClearExpectations(instance().get());
        }

        static void on(std::shared_ptr<graphic::api::MockOpenGL::PassContext> openglContext)
        {
            instance()->mockOn(openglContext);
        }

        MOCK_METHOD(void, mockOn, (std::shared_ptr<graphic::api::MockOpenGL::PassContext> openglContext), ());
    };
}

================================================================================
Contenu du fichier './tests/mock/graphic/opengl/pipeline/component/pass/MockFreer.hpp':
#pragma once

#include <memory>
#include <gmock/gmock.h>
#include <graphic/MockApi.hpp>
#include <graphic/opengl/profile/Pass.hpp>

namespace cenpy::mock::graphic::opengl::pipeline::component::pass
{
    template <auto PROFILE>
    class MockFreer
    {
    public:
        static std::shared_ptr<MockFreer<PROFILE>> instance()
        {
            static auto instance = std::make_shared<MockFreer<PROFILE>>();
            return instance;
        }

        static void reset()
        {
            ::testing::Mock::VerifyAndClearExpectations(instance().get());
        }

        static void on(std::shared_ptr<graphic::api::MockOpenGL::PassContext> openglContext)
        {
            instance()->mockOn(openglContext);
        }

        MOCK_METHOD(void, mockOn, (std::shared_ptr<graphic::api::MockOpenGL::PassContext>), ());
    };

}
================================================================================
Contenu du fichier './tests/mock/graphic/opengl/pipeline/component/pass/MockLoader.hpp':
#pragma once

#include <memory>
#include <gmock/gmock.h>
#include <graphic/MockApi.hpp>
#include <graphic/opengl/profile/Pass.hpp>

namespace cenpy::mock::graphic::opengl::pipeline::component::pass
{

    template <auto PROFILE>
    class MockLoader
    {
    public:
        static std::shared_ptr<MockLoader<PROFILE>> instance()
        {
            static auto instance = std::make_shared<MockLoader<PROFILE>>();
            return instance;
        }

        static void reset()
        {
            ::testing::Mock::VerifyAndClearExpectations(instance().get());
        }

        static void on(std::shared_ptr<graphic::api::MockOpenGL::PassContext> openglContext)
        {
            instance()->mockOn(openglContext);
        }

        MOCK_METHOD(void, mockOn, (std::shared_ptr<graphic::api::MockOpenGL::PassContext>), ());
    };
}

================================================================================
Contenu du fichier './tests/mock/graphic/opengl/pipeline/component/pass/MockShaderAttacher.hpp':
#pragma once

#include <memory>
#include <gmock/gmock.h>
#include <graphic/MockApi.hpp>
#include <graphic/opengl/profile/Pass.hpp>

namespace cenpy::mock::graphic::opengl::pipeline::component::pass
{
    template <auto PROFILE>
    class MockShaderAttacher
    {
    public:
        static std::shared_ptr<MockShaderAttacher<PROFILE>> instance()
        {
            static auto instance = std::make_shared<MockShaderAttacher<PROFILE>>();
            return instance;
        }

        static void reset()
        {
            ::testing::Mock::VerifyAndClearExpectations(instance().get());
        }

        static void on(std::shared_ptr<graphic::api::MockOpenGL::PassContext> openglContext)
        {
            instance()->mockOn(openglContext);
        }

        MOCK_METHOD(void, mockOn, (std::shared_ptr<graphic::api::MockOpenGL::PassContext> openglContext), ());
    };

}

================================================================================
Contenu du fichier './tests/mock/graphic/opengl/pipeline/component/pass/MockUniformReader.hpp':
#pragma once

#include <memory>
#include <gmock/gmock.h>
#include <graphic/MockApi.hpp>
#include <graphic/opengl/profile/Pass.hpp>

namespace cenpy::mock::graphic::opengl::pipeline::component::pass
{
    template <auto PROFILE>
    class MockUniformReader
    {
    public:
        static std::shared_ptr<MockUniformReader<PROFILE>> instance()
        {
            static auto instance = std::make_shared<MockUniformReader<PROFILE>>();
            return instance;
        }

        static void reset()
        {
            ::testing::Mock::VerifyAndClearExpectations(instance().get());
        }

        static void on(std::shared_ptr<graphic::api::MockOpenGL::PassContext> openglContext)
        {
            instance()->mockOn(openglContext);
        }

        MOCK_METHOD(void, mockOn, (std::shared_ptr<graphic::api::MockOpenGL::PassContext> openglContext), ());
    };
}

================================================================================
Contenu du fichier './tests/mock/graphic/opengl/pipeline/component/pass/MockUser.hpp':
#pragma once

#include <memory>
#include <gmock/gmock.h>
#include <graphic/MockApi.hpp>
#include <graphic/opengl/profile/Pass.hpp>

namespace cenpy::mock::graphic::opengl::pipeline::component::pass
{
    template <auto PROFILE>
    class MockUser
    {
    public:
        static std::shared_ptr<MockUser<PROFILE>> instance()
        {
            static auto instance = std::make_shared<MockUser<PROFILE>>();
            return instance;
        }

        static void reset()
        {
            ::testing::Mock::VerifyAndClearExpectations(instance().get());
        }

        static void on(std::shared_ptr<graphic::api::MockOpenGL::PassContext> openglContext)
        {
            instance()->mockOn(openglContext);
        }

        MOCK_METHOD(void, mockOn, (std::shared_ptr<graphic::api::MockOpenGL::PassContext>), ());
    };
}

================================================================================
Contenu du fichier './tests/mock/graphic/opengl/pipeline/component/pipeline/MockResetter.hpp':
#pragma once

#include <memory>
#include <gmock/gmock.h>
#include <graphic/MockApi.hpp>
#include <graphic/opengl/profile/Pipeline.hpp>

namespace cenpy::mock::graphic::opengl::pipeline::component::pipeline
{
    template <auto PROFILE>
    class MockResetter
    {
    public:
        static std::shared_ptr<MockResetter<PROFILE>> instance()
        {
            static auto instance = std::make_shared<MockResetter<PROFILE>>();
            return instance;
        }

        static void reset()
        {
            ::testing::Mock::VerifyAndClearExpectations(instance().get());
        }

        static void on(std::shared_ptr<graphic::api::MockOpenGL::PipelineContext> openglContext)
        {
            instance()->mockOn(openglContext);
        }

        MOCK_METHOD(void, mockOn, (std::shared_ptr<graphic::api::MockOpenGL::PipelineContext> context), ());
    };
}
================================================================================
Contenu du fichier './tests/mock/graphic/opengl/pipeline/component/pipeline/MockUser.hpp':
#pragma once

#include <memory>
#include <gmock/gmock.h>
#include <graphic/MockApi.hpp>
#include <graphic/opengl/profile/Pipeline.hpp>

namespace cenpy::mock::graphic::opengl::pipeline::component::pipeline
{
    template <auto PROFILE>
    class MockUser
    {
    public:
        static std::shared_ptr<MockUser<PROFILE>> instance()
        {
            static auto instance = std::make_shared<MockUser<PROFILE>>();
            return instance;
        }

        static void reset()
        {
            ::testing::Mock::VerifyAndClearExpectations(instance().get());
        }

        static void on(std::shared_ptr<graphic::api::MockOpenGL::PipelineContext> openglContext)
        {
            instance()->mockOn(openglContext);
        }

        MOCK_METHOD(void, mockOn, (std::shared_ptr<graphic::api::MockOpenGL::PipelineContext> context), ());
    };
}

================================================================================
Contenu du fichier './tests/mock/graphic/opengl/pipeline/component/shader/MockFreer.hpp':
#pragma once

#include <memory>
#include <gmock/gmock.h>
#include <graphic/MockApi.hpp>
#include <graphic/opengl/profile/Shader.hpp>

namespace cenpy::mock::graphic::opengl::pipeline::component::shader
{
    template <auto PROFILE>
    class MockFreer
    {
    public:
        static std::shared_ptr<MockFreer<PROFILE>> instance()
        {
            static auto instance = std::make_shared<MockFreer<PROFILE>>();
            return instance;
        }

        static void reset()
        {
            ::testing::Mock::VerifyAndClearExpectations(instance().get());
        }

        static void on(std::shared_ptr<graphic::api::MockOpenGL::ShaderContext> openglContext)
        {
            instance()->mockOn(openglContext);
        }

        MOCK_METHOD(void, mockOn, (std::shared_ptr<graphic::api::MockOpenGL::ShaderContext> context), ());
    };
}
================================================================================
Contenu du fichier './tests/mock/graphic/opengl/pipeline/component/shader/MockLoader.hpp':
// file: Loader.hpp

#pragma once

#include <memory>
#include <gmock/gmock.h>
#include <graphic/MockApi.hpp>
#include <graphic/opengl/profile/Shader.hpp>

namespace cenpy::mock::graphic::opengl::pipeline::component::shader
{
    template <auto PROFILE>
    class MockLoader
    {
    public:
        static std::shared_ptr<MockLoader<PROFILE>> instance()
        {
            static auto instance = std::make_shared<MockLoader<PROFILE>>();
            return instance;
        }

        static void reset()
        {
            ::testing::Mock::VerifyAndClearExpectations(instance().get());
        }

        static void on(std::shared_ptr<graphic::api::MockOpenGL::ShaderContext> openglContext)
        {
            instance()->mockOn(openglContext);
        }

        MOCK_METHOD(void, mockOn, (std::shared_ptr<graphic::api::MockOpenGL::ShaderContext>), ());
    };

}
================================================================================
Contenu du fichier './tests/mock/graphic/opengl/pipeline/component/shader/MockReader.hpp':
// file: Reader.hpp

#pragma once

#include <memory>
#include <gmock/gmock.h>
#include <graphic/MockApi.hpp>
#include <graphic/opengl/profile/Shader.hpp>

namespace cenpy::mock::graphic::opengl::pipeline::component::shader
{
    template <auto PROFILE>
    class MockReader
    {
    public:
        static std::shared_ptr<MockReader<PROFILE>> instance()
        {
            static auto instance = std::make_shared<MockReader<PROFILE>>();
            return instance;
        }

        static void reset()
        {
            ::testing::Mock::VerifyAndClearExpectations(instance().get());
        }

        static void on(std::shared_ptr<graphic::api::MockOpenGL::ShaderContext> openglContext)
        {
            instance()->mockOn(openglContext);
        }

        MOCK_METHOD(void, mockOn, (std::shared_ptr<graphic::api::MockOpenGL::ShaderContext>), ());
    };
}
================================================================================
Contenu du fichier './tests/mock/graphic/opengl/pipeline/component/uniform/MockSetter.hpp':
#pragma once

#include <GL/glew.h>
#include <memory>
#include <gmock/gmock.h>
#include <graphic/MockApi.hpp>

namespace cenpy::mock::graphic::opengl
{
    namespace context
    {

        class MockUniformContext;
    }
    namespace pipeline::component::uniform
    {

        template <typename U>
        struct MockSetter
        {
            static constexpr GLenum glType = GL_INVALID_ENUM;
        };
        /**
         * @brief Specialization for GLfloat with corresponding setter
         */
        template <>
        struct MockSetter<GLfloat>
        {
            static void on(std::shared_ptr<graphic::api::MockOpenGL::UniformContext> uniform)
            {
                glUniform1f(1, 3.14f);
            }

            static constexpr GLenum glType = GL_FLOAT;
        };

        /**
         * @brief Specialization for GLfloat with corresponding setter
         */
        template <>
        struct MockSetter<GLint>
        {
            static void on(std::shared_ptr<graphic::api::MockOpenGL::UniformContext> uniform)
            {
                glUniform1i(1, 1);
            }

            static constexpr GLenum glType = GL_INT;
        };

    }
}

================================================================================
Contenu du fichier './tests/mock/graphic/pipeline/MockAttribute.hpp':

#pragma once

#include <gmock/gmock.h>
#include <graphic/pipeline/Attribute.hpp>
#include <graphic/opengl/context/MockAttributeContext.hpp>

namespace cenpy::mock::graphic::pipeline
{
    template <typename API>
    class MockAttribute : public cenpy::graphic::pipeline::IAttribute<API>
    {
    public:
        MockAttribute() : cenpy::graphic::pipeline::IAttribute<API>()
        {
        }

    protected:
        MOCK_METHOD(void, bind, (std::shared_ptr<typename API::AttributeContext> context), (override));
        MOCK_METHOD(void, unbind, (std::shared_ptr<typename API::AttributeContext> context), (override));
    };

} // namespace cenpy::graphic::pipeline

================================================================================
Contenu du fichier './tests/mock/graphic/pipeline/MockPass.hpp':
#pragma once

#include <gmock/gmock.h>
#include <graphic/pipeline/MockShader.hpp>
#include <graphic/opengl/context/MockPassContext.hpp>
#include <graphic/opengl/pipeline/component/pass/MockShaderAttacher.hpp>
#include <graphic/opengl/pipeline/component/pass/MockUniformReader.hpp>
#include <graphic/opengl/pipeline/component/pass/MockAttributeReader.hpp>
#include <graphic/opengl/pipeline/component/pass/MockUser.hpp>
#include <graphic/opengl/pipeline/component/pass/MockFreer.hpp>
#include <graphic/opengl/pipeline/component/pass/MockLoader.hpp>
#include <graphic/pipeline/Pass.hpp>

namespace cenpy::mock::graphic::pipeline::opengl
{
    namespace pipeline = cenpy::graphic::pipeline;

    template <typename API>
    class MockPass : public pipeline::IPass<API>
    {
    public:
        MockPass() : pipeline::IPass<API>({})
        {
        }

        MOCK_METHOD(void, use, (), (override));
        MOCK_METHOD(void, load, (), (override));

        MOCK_METHOD((const std::unordered_map<std::string, std::shared_ptr<pipeline::Uniform<API>>, collection_utils::StringHash, collection_utils::StringEqual> &), getUniforms, (), (const, override));
        MOCK_METHOD((const std::vector<std::shared_ptr<pipeline::IShader<API>>> &), getShaders, (), (const, override));

    protected:
        MOCK_METHOD(void, readUniforms, (std::shared_ptr<typename API::PassContext> context), (override));
        MOCK_METHOD(void, readAttributes, (std::shared_ptr<typename API::PassContext> context), (override));
        MOCK_METHOD(void, free, (std::shared_ptr<typename API::PassContext> context), (override));
        MOCK_METHOD(void, use, (std::shared_ptr<typename API::PassContext> context), (override));
        MOCK_METHOD(void, load, (std::shared_ptr<typename API::PassContext> context), (override));

        MOCK_METHOD((std::shared_ptr<pipeline::IPass<API>>), shared, (), (const, override));
    };
}

================================================================================
Contenu du fichier './tests/mock/graphic/pipeline/MockShader.hpp':
#pragma once

#include <gmock/gmock.h>
#include <graphic/MockApi.hpp>
#include <graphic/pipeline/MockUniform.hpp>
#include <graphic/opengl/context/MockShaderContext.hpp>
#include <graphic/pipeline/Shader.hpp>

namespace cenpy::mock::graphic::pipeline
{
    namespace api = cenpy::mock::graphic::api;
    namespace context = cenpy::graphic::context;
    namespace pipeline = cenpy::graphic::pipeline;

    template <typename API>
    class MockShader : public pipeline::IShader<API>
    {
    public:
        MockShader() : pipeline::IShader<API>("", context::ShaderType::VERTEX) {}
        MockShader(const std::string &path, context::ShaderType type) : pipeline::IShader<API>(path, type) {}

        MOCK_METHOD(void, free, (), (override));
        MOCK_METHOD(void, load, (), (override));
        MOCK_METHOD(const std::shared_ptr<typename API::ShaderContext> &, getContext, (), (const, override));

    protected:
        MOCK_METHOD(void, load, (std::shared_ptr<typename API::ShaderContext>), (override));
        MOCK_METHOD(void, free, (std::shared_ptr<typename API::ShaderContext>), (override));
        MOCK_METHOD(void, read, (std::shared_ptr<typename API::ShaderContext>), (override));
    };

}

================================================================================
Contenu du fichier './tests/mock/graphic/pipeline/MockUniform.hpp':

#pragma once

#include <gmock/gmock.h>
#include <graphic/pipeline/Uniform.hpp>
#include <graphic/opengl/context/MockUniformContext.hpp>

namespace cenpy::mock::graphic::pipeline
{

    template <typename API>
    class MockUniform : public cenpy::graphic::pipeline::Uniform<API>
    {
    public:
        MockUniform() : cenpy::graphic::pipeline::Uniform<API>()
        {
        }
    };

} // namespace cenpy::graphic::pipeline

================================================================================
Contenu du fichier './tests/src/graphic/opengl/context/ShaderContextTests.cpp':
#include <gtest/gtest.h>
#include <graphic/opengl/context/ShaderContext.hpp>

using namespace cenpy::graphic::context;
using namespace cenpy::graphic::opengl::context;

// Test fixture for ShaderContext
class ShaderContextTests : public ::testing::Test
{
protected:
    // Create a new instance of ShaderContext for each test case
    void SetUp() override
    {
        m_shaderContext = std::make_unique<OpenGLShaderContext>();
    }

    // Clean up resources after each test case
    void TearDown() override
    {
        m_shaderContext.reset();
    }

    std::unique_ptr<OpenGLShaderContext> m_shaderContext;
};

// Test case for setting and getting shader type
TEST_F(ShaderContextTests, SetAndGetShaderTypeforVertexShader)
{
    ShaderType shaderType = ShaderType::VERTEX;
    m_shaderContext->setShaderType(shaderType);
    EXPECT_EQ(m_shaderContext->getShaderType(), shaderType);
    EXPECT_EQ(m_shaderContext->getGLShaderType(), GL_VERTEX_SHADER);
}

TEST_F(ShaderContextTests, SetAndGetShaderTypeforFragmentShader)
{
    ShaderType shaderType = ShaderType::FRAGMENT;
    m_shaderContext->setShaderType(shaderType);
    EXPECT_EQ(m_shaderContext->getShaderType(), shaderType);
    EXPECT_EQ(m_shaderContext->getGLShaderType(), GL_FRAGMENT_SHADER);
}

TEST_F(ShaderContextTests, SetAndGetShaderTypeforGeometryShader)
{
    ShaderType shaderType = ShaderType::GEOMETRY;
    m_shaderContext->setShaderType(shaderType);
    EXPECT_EQ(m_shaderContext->getShaderType(), shaderType);
    EXPECT_EQ(m_shaderContext->getGLShaderType(), GL_GEOMETRY_SHADER);
}

TEST_F(ShaderContextTests, SetAndGetShaderTypeforTessellationControlShader)
{
    ShaderType shaderType = ShaderType::TESS_CONTROL;
    m_shaderContext->setShaderType(shaderType);
    EXPECT_EQ(m_shaderContext->getShaderType(), shaderType);
    EXPECT_EQ(m_shaderContext->getGLShaderType(), GL_TESS_CONTROL_SHADER);
}

TEST_F(ShaderContextTests, SetAndGetShaderTypeforTessellationEvaluationShader)
{
    ShaderType shaderType = ShaderType::TESS_EVALUATION;
    m_shaderContext->setShaderType(shaderType);
    EXPECT_EQ(m_shaderContext->getShaderType(), shaderType);
    EXPECT_EQ(m_shaderContext->getGLShaderType(), GL_TESS_EVALUATION_SHADER);
}

TEST_F(ShaderContextTests, SetAndGetShaderTypeforComputeShader)
{
    ShaderType shaderType = ShaderType::COMPUTE;
    m_shaderContext->setShaderType(shaderType);
    EXPECT_EQ(m_shaderContext->getShaderType(), shaderType);
    EXPECT_EQ(m_shaderContext->getGLShaderType(), GL_COMPUTE_SHADER);
}

// Add more test cases as needed

================================================================================
Contenu du fichier './tests/src/graphic/opengl/pipeline/component/attribute/BinderTests.cpp':
#ifdef __mock_gl__

#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <memory>
#include <opengl/glFunctionMock.hpp>
#include <graphic/Api.hpp>
#include <graphic/opengl/context/AttributeContext.hpp>
#include <graphic/opengl/pipeline/component/attribute/Binder.hpp>
#include <common/exception/TraceableException.hpp>
#include <TestUtils.hpp>

namespace api = cenpy::graphic::api;
namespace mock = cenpy::mock;
namespace context = cenpy::graphic::opengl::context;
namespace attribute = cenpy::graphic::opengl::pipeline::component::attribute;
using cenpy::graphic::opengl::profile::Attribute::Classic;
using cenpy::test::utils::expectSpecificError;

class AttributeBinderTests : public ::testing::Test
{
protected:
    void TearDown() override
    {
        mock::opengl::glFunctionMock::reset();
    }
};

TEST_F(AttributeBinderTests, BindAttributeTest_createBuffer)
{
    // Arrange
    auto attributeContext = std::make_shared<api::OpenGL::AttributeContext>();
    attributeContext->setBufferID(0);
    attributeContext->setGLType(GL_FLOAT);
    attributeContext->setGLSize(1);

    auto binder = std::make_shared<attribute::OpenGLBinder<Classic>>();

    // Expected call
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glGenBuffers_mock(1, ::testing::_))
        .Times(1)
        .WillOnce(::testing::Invoke([](GLsizei, GLuint *buffer)
                                    { *buffer = 42; }));

    // Act
    ASSERT_NO_THROW(binder->on(attributeContext));

    // Assert
    ASSERT_EQ(attributeContext->getBufferID(), 42);
}

TEST_F(AttributeBinderTests, BindAttributeTest_bindBuffer)
{
    // Arrange
    auto attributeContext = std::make_shared<api::OpenGL::AttributeContext>();
    attributeContext->setBufferID(42);
    attributeContext->setGLType(GL_FLOAT);
    attributeContext->setGLSize(1);

    auto binder = std::make_shared<attribute::OpenGLBinder<Classic>>();

    // Expected call
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glBindBuffer_mock(GL_ARRAY_BUFFER, 42))
        .Times(1);

    // Act
    ASSERT_NO_THROW(binder->on(attributeContext));

    // Assert
    ASSERT_EQ(attributeContext->getBufferID(), 42);
}

TEST_F(AttributeBinderTests, BindAttributeTest_invalidContext)
{
    // Arrange
    auto binder = std::make_shared<attribute::OpenGLBinder<Classic>>();

    // Act & Assert
    expectSpecificError([&binder]()
                        { binder->on(nullptr); },
                        cenpy::common::exception::TraceableException<std::runtime_error>(std::format("ERROR::ATTRIBUTE::SET::NON_OPENGL_CONTEXT")));
}

#endif // __mock_gl__
================================================================================
Contenu du fichier './tests/src/graphic/opengl/pipeline/component/attribute/SetterTests.cpp':
#ifdef __mock_gl__

#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <memory>
#include <opengl/glFunctionMock.hpp>
#include <graphic/Api.hpp>
#include <graphic/opengl/context/AttributeContext.hpp>
#include <graphic/opengl/pipeline/component/attribute/Setter.hpp>
#include <common/exception/TraceableException.hpp>
#include <TestUtils.hpp>

namespace api = cenpy::graphic::api;
namespace mock = cenpy::mock;
namespace context = cenpy::graphic::opengl::context;
namespace attribute = cenpy::graphic::opengl::pipeline::component::attribute;

using cenpy::test::utils::expectSpecificError;

class AttributeSetterTests : public ::testing::Test
{
protected:
    void TearDown() override
    {
        mock::opengl::glFunctionMock::reset();
    }
};

TEST_F(AttributeSetterTests, SetAttributeTest_CallBufferData)
{
    // Arrange
    std::shared_ptr<context::OpenGLAttributeContext> attribute = std::make_shared<context::OpenGLAttributeContext>();
    attribute->setBufferID(1);
    attribute->setGLUsage(GL_STATIC_DRAW);
    std::shared_ptr<float> attrValue = std::make_shared<float>(1.0f);
    attribute->setValue(attrValue);

    // Expected call
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glBufferData_mock(GL_ARRAY_BUFFER, sizeof(attrValue.get()), attrValue.get(), GL_STATIC_DRAW))
        .Times(1);

    // Act
    attribute::OpenGLSetter<float>::on(attribute);
}

TEST_F(AttributeSetterTests, SetAttributeTest_CallVertexAttribPointer)
{
    // Arrange
    std::shared_ptr<context::OpenGLAttributeContext> attribute = std::make_shared<context::OpenGLAttributeContext>();
    attribute->setBufferID(1);
    attribute->setGLUsage(GL_STATIC_DRAW);
    attribute->setAttributeID(1);
    attribute->setGLSize(1);
    attribute->setGLType(GL_FLOAT);
    std::shared_ptr<float> attrValue = std::make_shared<float>(1.0f);
    attribute->setValue(attrValue);

    // Expected call
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glVertexAttribPointer_mock(1, 1, GL_FLOAT, GL_FALSE, sizeof(attrValue.get()), (void *)nullptr))
        .Times(1);

    // Act
    attribute::OpenGLSetter<float>::on(attribute);
}

TEST_F(AttributeSetterTests, SetAttributeTest_ThrowExceptionWhenContextIsNullptr)
{
    // Act & Assert
    expectSpecificError<std::runtime_error>([&]()
                                            { attribute::OpenGLSetter<float>::on(nullptr); },
                                            cenpy::common::exception::TraceableException<std::runtime_error>("ERROR::ATTRIBUTE::SET::NON_OPENGL_CONTEXT"));
}

TEST_F(AttributeSetterTests, SetAttributeTest_ThrowExceptionWhenBufferIsNotSet)
{
    // Arrange
    std::shared_ptr<context::OpenGLAttributeContext> attribute = std::make_shared<context::OpenGLAttributeContext>();

    // Act & Assert
    expectSpecificError<std::runtime_error>([&]()
                                            { attribute::OpenGLSetter<float>::on(attribute); },
                                            cenpy::common::exception::TraceableException<std::runtime_error>("ERROR::ATTRIBUTE::SET::BUFFER_ID_NOT_SET"));
}

#endif // __mock_gl__
================================================================================
Contenu du fichier './tests/src/graphic/opengl/pipeline/component/attribute/UnbinderTests.cpp':
#ifdef __mock_gl__

#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <memory>
#include <opengl/glFunctionMock.hpp>
#include <graphic/Api.hpp>
#include <graphic/opengl/context/AttributeContext.hpp>
#include <graphic/opengl/pipeline/component/attribute/Unbinder.hpp>
#include <common/exception/TraceableException.hpp>
#include <TestUtils.hpp>

namespace api = cenpy::graphic::api;
namespace mock = cenpy::mock;
namespace context = cenpy::graphic::opengl::context;
namespace attribute = cenpy::graphic::opengl::pipeline::component::attribute;
using cenpy::graphic::opengl::profile::Attribute::Classic;
using cenpy::test::utils::expectSpecificError;

class AttributeUnbinderTests : public ::testing::Test
{
protected:
    void TearDown() override
    {
        mock::opengl::glFunctionMock::reset();
    }
};

TEST_F(AttributeUnbinderTests, BindAttributeTest_unbindBuffer)
{
    // Arrange
    auto attributeContext = std::make_shared<api::OpenGL::AttributeContext>();
    attributeContext->setBufferID(42);

    auto unbinder = std::make_shared<attribute::OpenGLUnbinder<Classic>>();

    // Expected call
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glBindBuffer_mock(GL_ARRAY_BUFFER, 0))
        .Times(1);

    // Act
    ASSERT_NO_THROW(unbinder->on(attributeContext));
}

TEST_F(AttributeUnbinderTests, BindAttributeTest_nullContext)
{
    // Arrange
    auto unbinder = std::make_shared<attribute::OpenGLUnbinder<Classic>>();

    // Act & Assert
    expectSpecificError([&unbinder]()
                        { unbinder->on(nullptr); },
                        cenpy::common::exception::TraceableException<std::runtime_error>("ERROR::ATTRIBUTE::UNBIND::NON_OPENGL_CONTEXT"));
}

TEST_F(AttributeUnbinderTests, BindAttributeTest_defaultBindID)
{
    // Arrange
    auto attributeContext = std::make_shared<api::OpenGL::AttributeContext>();
    attributeContext->setBufferID(0);

    auto unbinder = std::make_shared<attribute::OpenGLUnbinder<Classic>>();

    // Expected call
    expectSpecificError([&unbinder, &attributeContext]()
                        { unbinder->on(attributeContext); },
                        cenpy::common::exception::TraceableException<std::runtime_error>("ERROR::ATTRIBUTE::UNBIND::BUFFER_ID_NOT_SET"));
}

#endif // __mock_gl__
================================================================================
Contenu du fichier './tests/src/graphic/opengl/pipeline/component/pass/AttributeReaderTests.cpp':
#ifdef __mock_gl__

#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <memory>
#include <opengl/glFunctionMock.hpp>
#include <graphic/opengl/context/PassContext.hpp>
#include <graphic/opengl/pipeline/component/attribute/Setter.hpp>
#include <graphic/opengl/pipeline/component/attribute/Binder.hpp>
#include <graphic/opengl/pipeline/component/attribute/Unbinder.hpp>

#include <graphic/opengl/validator/Validator.hpp>
#include <graphic/opengl/profile/Pass.hpp>

#include <graphic/opengl/pipeline/component/pass/AttributeReader.hpp>
#include <TestUtils.hpp>

namespace context = cenpy::graphic::opengl::context;
namespace pass = cenpy::graphic::opengl::pipeline::component::pass;
namespace mock = cenpy::mock;
using cenpy::graphic::opengl::profile::Pass::Classic;
using cenpy::test::utils::expectSpecificError;

class AttributeReaderTests : public ::testing::Test
{
protected:
    void TearDown() override
    {
        mock::opengl::glFunctionMock::reset();
    }
};

TEST_F(AttributeReaderTests, ReadAttributes_CallGetProgramiv)
{
    // Arrange
    auto openglContext = std::make_shared<context::OpenGLPassContext>();
    openglContext->setPassID(1); // Set a valid pipeline ID

    // Mock the OpenGL calls to simulate attributes
    GLint numAttributes = 0; // For example, 2 attributes
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glGetProgramiv_mock(1, GL_ACTIVE_ATTRIBUTES, ::testing::_))
        .WillOnce(::testing::SetArgPointee<2>(numAttributes));

    // Act
    ASSERT_NO_THROW(pass::OpenGLPassAttributeReader<Classic>::on(openglContext));
}

TEST_F(AttributeReaderTests, ReadAttributes_CallGetActiveAttribAndGetAttribLocation)
{
    // Arrange
    auto openglContext = std::make_shared<context::OpenGLPassContext>();
    openglContext->setPassID(1); // Set a valid pipeline ID

    // Mock the OpenGL calls to simulate attributes
    GLint numAttributes = 1; // For example, 2 attributes
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glGetProgramiv_mock(1, GL_ACTIVE_ATTRIBUTES, ::testing::_))
        .WillOnce(::testing::SetArgPointee<2>(numAttributes));

    // Mock calls to glGetActiveAttribute and glGetAttributeLocation for each attribute
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glGetActiveAttrib_mock(1, 0, ::testing::_, ::testing::_, ::testing::_, ::testing::_, ::testing::_))
        .Times(1);
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glGetAttribLocation_mock(1, ::testing::_))
        .Times(1);

    // Act
    ASSERT_NO_THROW(pass::OpenGLPassAttributeReader<Classic>::on(openglContext));

    // Assert
    // Optionally check if the attributes are correctly added to the context
    ASSERT_EQ(openglContext->getAttributes().size(), 1);
    ASSERT_TRUE(openglContext->getAttributes().contains(mock::opengl::glFunctionMock::ATTRIBUTE_NAME));
}

TEST_F(AttributeReaderTests, ReadAttributes_NullContext)
{
    // Arrange

    // Act & Assert
    expectSpecificError([]()
                        { pass::OpenGLPassAttributeReader<Classic>::on(nullptr); },
                        cenpy::common::exception::TraceableException<std::runtime_error>("ERROR::PASS::NON_OPENGL_CONTEXT"));
}

TEST_F(AttributeReaderTests, ReadAttributes_InvalidPassID)
{
    // Arrange
    auto openglContext = std::make_shared<context::OpenGLPassContext>(); // No pipeline ID set

    // Act & Assert
    expectSpecificError([&openglContext]()
                        { pass::OpenGLPassAttributeReader<Classic>::on(openglContext); },
                        cenpy::common::exception::TraceableException<std::runtime_error>("ERROR::PASS::INVALID_PROGRAM_ID"));
}

#endif // __mock_gl__
================================================================================
Contenu du fichier './tests/src/graphic/opengl/pipeline/component/pass/FreerTests.cpp':
#ifdef __mock_gl__

#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <memory>
#include <opengl/glFunctionMock.hpp>
#include <graphic/Api.hpp>
#include <graphic/pipeline/MockShader.hpp>
#include <graphic/opengl/pipeline/component/uniform/MockSetter.hpp>
#include <graphic/opengl/context/PassContext.hpp>
#include <graphic/opengl/profile/Pass.hpp>
#include <graphic/opengl/pipeline/component/pass/Freer.hpp>

namespace api = cenpy::graphic::api;
namespace mock = cenpy::mock;
namespace context = cenpy::graphic::opengl::context;
namespace pass = cenpy::graphic::opengl::pipeline::component::pass;
using cenpy::graphic::opengl::profile::Pass::Classic;
using MockShader = cenpy::mock::graphic::pipeline::MockShader<api::OpenGL>;

class PassFreerTests : public ::testing::Test
{
protected:
    void TearDown() override
    {
        mock::opengl::glFunctionMock::reset();
    }
};

TEST_F(PassFreerTests, FreePassTest_validContext)
{
    // Arrange
    auto openglContext = std::make_shared<context::OpenGLPassContext>();
    auto openglShaderContext = std::make_shared<context::OpenGLShaderContext>();
    auto *shader1 = new MockShader("shader_path", cenpy::graphic::context::ShaderType::VERTEX);
    delete shader1;
    auto shader = std::make_shared<MockShader>("shader_path", cenpy::graphic::context::ShaderType::VERTEX);
    openglContext->addShader(shader);
    openglContext->setPassID(1);          // Set a mock pipeline ID
    openglShaderContext->setShaderID(42); // Set a mock shader ID

    // Expect calls for valid context
    ON_CALL(*shader, getContext()).WillByDefault(::testing::ReturnRef(openglShaderContext));
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glDetachShader_mock(1, 42)).Times(::testing::AtLeast(1));
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glDeleteProgram_mock(1)).Times(1);

    // Act
    ASSERT_NO_THROW(pass::OpenGLPassFreer<Classic>::on(openglContext));

    // Assert
    ASSERT_EQ(openglContext->getPassID(), 0);
}

TEST_F(PassFreerTests, FreePassTest_nullContext)
{
    // Arrange

    // Act & Assert
    EXPECT_THROW(pass::OpenGLPassFreer<Classic>::on(nullptr), std::runtime_error);
}

TEST_F(PassFreerTests, FreePassTest_noPassID)
{
    // Arrange
    auto openglContext = std::make_shared<context::OpenGLPassContext>(); // No pipeline ID set

    // Act & Assert
    ASSERT_NO_THROW(pass::OpenGLPassFreer<Classic>::on(openglContext));
    ASSERT_EQ(openglContext->getPassID(), 0); // Ensure pipeline ID remains 0
}

TEST_F(PassFreerTests, FreePassTest_detachShaders)
{
    // Arrange
    auto openglContext = std::make_shared<context::OpenGLPassContext>();
    openglContext->setPassID(1); // Set a mock pipeline ID

    // Add mock shaders to context
    // ...

    // Expect detach calls for each shader
    // ...

    // Act & Assert
    ASSERT_NO_THROW(pass::OpenGLPassFreer<Classic>::on(openglContext));
}

TEST_F(PassFreerTests, FreePassTest_deletePipeline)
{
    // Arrange
    auto openglContext = std::make_shared<context::OpenGLPassContext>();
    openglContext->setPassID(1); // Set a mock pipeline ID

    // Expect delete call
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glDeleteProgram_mock(1)).Times(1);

    // Act & Assert
    ASSERT_NO_THROW(pass::OpenGLPassFreer<Classic>::on(openglContext));
}

TEST_F(PassFreerTests, FreePassTest_noShaders)
{
    // Arrange
    auto openglContext = std::make_shared<context::OpenGLPassContext>();
    openglContext->setPassID(1); // Set a mock pipeline ID

    // Expect no detach calls
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glDetachShader_mock(::testing::_, ::testing::_)).Times(0);

    // Act & Assert
    ASSERT_NO_THROW(pass::OpenGLPassFreer<Classic>::on(openglContext));
}

#endif // __mock_gl__
================================================================================
Contenu du fichier './tests/src/graphic/opengl/pipeline/component/pass/LoaderTests.cpp':
#ifdef __mock_gl__

#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <memory>
#include <opengl/glFunctionMock.hpp>
#include <graphic/MockApi.hpp>
#include <graphic/opengl/context/PassContext.hpp>
#include <graphic/opengl/profile/Pass.hpp>
#include <graphic/opengl/pipeline/component/pass/MockShaderAttacher.hpp>
#include <graphic/opengl/pipeline/component/pass/Loader.hpp>
#include <TestUtils.hpp>

namespace mock = cenpy::mock;
namespace mock_component = cenpy::mock::graphic::opengl::pipeline::component::pass;
namespace context = cenpy::graphic::opengl::context;
namespace api = cenpy::graphic::api;
namespace pass = cenpy::graphic::opengl::pipeline::component::pass;

using cenpy::graphic::opengl::profile::Pass::Classic;
using cenpy::test::utils::expectSpecificError;

class LoaderTests : public ::testing::Test
{
public:
    void TearDown() override
    {
        mock::opengl::glFunctionMock::reset();
    }
};

TEST_F(LoaderTests, LoadPassTest_validContext)
{
    // Arrange
    auto openglContext = std::make_shared<context::OpenGLPassContext>();

    // Act
    ASSERT_NO_THROW(pass::OpenGLLoader<Classic>::on(openglContext));

    // Assert
    ASSERT_EQ(openglContext->getPassID(), 1);
}

TEST_F(LoaderTests, LoadPassTest_createPipeline)
{
    // Arrange
    auto openglContext = std::make_shared<context::OpenGLPassContext>();

    // Expect calls for valid context
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glCreateProgram_mock()).Times(1);

    // Act
    ASSERT_NO_THROW(pass::OpenGLLoader<Classic>::on(openglContext));
}

TEST_F(LoaderTests, LoadPassTest_linkPipeline)
{
    // Arrange
    auto openglContext = std::make_shared<context::OpenGLPassContext>();

    // Expect calls for valid context
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glLinkProgram_mock(1)).Times(1);

    // Act
    ASSERT_NO_THROW(pass::OpenGLLoader<Classic>::on(openglContext));
}

TEST_F(LoaderTests, LoadPassTest_nullContext)
{
    // Arrange
    // Act & Assert
    expectSpecificError([]()
                        { pass::OpenGLLoader<Classic>::on(nullptr); },
                        cenpy::common::exception::TraceableException<std::runtime_error>(std::format("ERROR::SHADER::PROGRAM::NON_OPENGL_CONTEXT")));
}

TEST_F(LoaderTests, LoadPassTest_pipelineCreationFailed)
{
    // Arrange
    auto openglContext = std::make_shared<context::OpenGLPassContext>();

    // Expect calls for pipeline creation failure
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glCreateProgram_mock())
        .WillOnce(::testing::Return(0));

    // Act & Assert
    expectSpecificError([&openglContext]()
                        { pass::OpenGLLoader<Classic>::on(openglContext); },
                        cenpy::common::exception::TraceableException<std::runtime_error>(std::format("ERROR::SHADER::PROGRAM_CREATION_FAILED\nFailed to create shader pipeline.")));
}

TEST_F(LoaderTests, LoadPassTest_linkFailed)
{
    // Arrange
    auto openglContext = std::make_shared<context::OpenGLPassContext>();

    // Set mock behavior for link failure

    // Expect calls for link failure
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glGetProgramiv_mock(1, GL_LINK_STATUS, ::testing::_))
        .Times(1)
        .WillOnce(::testing::Invoke([](GLuint program, GLenum pname, GLint *params)
                                    { *params = GL_FALSE; }));
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glGetProgramiv_mock(1, GL_INFO_LOG_LENGTH, ::testing::_))
        .Times(1)
        .WillOnce(::testing::Invoke([](GLuint program, GLenum pname, GLint *params)
                                    { *params = 300; }));
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glGetProgramInfoLog_mock(1, 300, ::testing::_, ::testing::_)).Times(1);
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glDeleteProgram_mock(1)).Times(1);

    // Act & Assert
    expectSpecificError([&openglContext]()
                        { pass::OpenGLLoader<Classic>::on(openglContext); },
                        cenpy::common::exception::TraceableException<std::runtime_error>(std::format("ERROR::SHADER::PROGRAM::LINK_FAILED")));
}

TEST_F(LoaderTests, LoadPassTest_linkSuccess)
{
    // Arrange
    auto openglContext = std::make_shared<context::OpenGLPassContext>();

    // Set mock behavior for link success

    // Expect calls for link success
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glGetProgramiv_mock(1, GL_LINK_STATUS, ::testing::_))
        .Times(1)
        .WillOnce(::testing::Invoke([](GLuint program, GLenum pname, GLint *params)
                                    { *params = GL_TRUE; }));

    // Act & Assert
    ASSERT_NO_THROW(pass::OpenGLLoader<Classic>::on(openglContext));
}

#endif // __mock_gl__

================================================================================
Contenu du fichier './tests/src/graphic/opengl/pipeline/component/pass/ShaderAttacherTests.cpp':
#ifdef __mock_gl__

#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <memory>
#include <graphic/Api.hpp>
#include <opengl/glFunctionMock.hpp>
#include <graphic/opengl/context/PassContext.hpp>
#include <graphic/opengl/context/ShaderContext.hpp>
#include <graphic/opengl/profile/Pass.hpp>
#include <graphic/pipeline/MockShader.hpp>
#include <graphic/opengl/pipeline/component/pass/ShaderAttacher.hpp>
#include <TestUtils.hpp>

namespace context = cenpy::graphic::opengl::context;
namespace pass = cenpy::graphic::opengl::pipeline::component::pass;
namespace mock = cenpy::mock;
namespace shader = mock::graphic::pipeline;
using MockShader = cenpy::mock::graphic::pipeline::MockShader<cenpy::graphic::api::OpenGL>;
using cenpy::graphic::opengl::profile::Pass::Classic;
using cenpy::test::utils::expectSpecificError;

class ShaderAttacherTests : public ::testing::Test
{
protected:
    void TearDown() override
    {
        mock::opengl::glFunctionMock::reset();
    }
};

TEST_F(ShaderAttacherTests, AttachShaders_ValidContext)
{
    // Arrange
    auto openglContext = std::make_shared<context::OpenGLPassContext>();
    auto shaderContext = std::make_shared<context::OpenGLShaderContext>();
    auto shader = std::make_shared<MockShader>();
    openglContext->setPassID(1);      // Set a valid pipeline ID
    openglContext->addShader(shader); // Add a mock shader
    shaderContext->setShaderID(42);   // Set a mock shader ID

    // Expect calls for valid context
    EXPECT_CALL(*shader, getContext()).WillRepeatedly(::testing::ReturnRef(shaderContext));
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glAttachShader_mock(1, 42)).Times(1);

    // Act & Assert
    ASSERT_NO_THROW(pass::OpenGLShaderAttacher<Classic>::on(openglContext));
}

TEST_F(ShaderAttacherTests, AttachShaders_NullContext)
{
    // Arrange

    // Act & Assert
    expectSpecificError([]()
                        { pass::OpenGLShaderAttacher<Classic>::on(nullptr); },
                        cenpy::common::exception::TraceableException<std::runtime_error>("ERROR::SHADER::NON_OPENGL_CONTEXT"));
}

TEST_F(ShaderAttacherTests, AttachShaders_InvalidPassID)
{
    // Arrange
    auto openglContext = std::make_shared<context::OpenGLPassContext>(); // No pipeline ID set

    // Act & Assert
    expectSpecificError([&openglContext]()
                        { pass::OpenGLShaderAttacher<Classic>::on(openglContext); },
                        cenpy::common::exception::TraceableException<std::runtime_error>("ERROR::SHADER::INVALID_PROGRAM_ID"));
}

TEST_F(ShaderAttacherTests, AttachShaders_NoShaders)
{
    // Arrange
    auto openglContext = std::make_shared<context::OpenGLPassContext>();
    openglContext->setPassID(1); // Set a valid pipeline ID

    // Act & Assert
    ASSERT_NO_THROW(pass::OpenGLShaderAttacher<Classic>::on(openglContext));
}

#endif // __mock_gl__
================================================================================
Contenu du fichier './tests/src/graphic/opengl/pipeline/component/pass/UniformReaderTests.cpp':
#ifdef __mock_gl__

#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <memory>
#include <opengl/glFunctionMock.hpp>
#include <graphic/opengl/context/PassContext.hpp>
#include <graphic/opengl/pipeline/component/uniform/MockSetter.hpp>

#include <graphic/opengl/validator/Validator.hpp>
#include <graphic/opengl/profile/Pass.hpp>

#include <graphic/opengl/pipeline/component/pass/UniformReader.hpp>
#include <TestUtils.hpp>

namespace context = cenpy::graphic::opengl::context;
namespace pass = cenpy::graphic::opengl::pipeline::component::pass;
namespace mock = cenpy::mock;
using cenpy::graphic::opengl::profile::Pass::Classic;
using cenpy::test::utils::expectSpecificError;

class UniformReaderTests : public ::testing::Test
{
protected:
    void TearDown() override
    {
        mock::opengl::glFunctionMock::reset();
    }
};

TEST_F(UniformReaderTests, ReadUniforms_ValidContext)
{
    // Arrange
    auto openglContext = std::make_shared<context::OpenGLPassContext>();
    openglContext->setPassID(1); // Set a valid pipeline ID

    // Mock the OpenGL calls to simulate uniforms
    GLint numUniforms = 1; // For example, 2 uniforms
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glGetProgramiv_mock(1, GL_ACTIVE_UNIFORMS, ::testing::_))
        .WillOnce(::testing::SetArgPointee<2>(numUniforms));

    // Mock calls to glGetActiveUniform and glGetUniformLocation for each uniform
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glGetActiveUniform_mock(1, 0, ::testing::_, ::testing::_, ::testing::_, ::testing::_, ::testing::_)).Times(1);
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glGetUniformLocation_mock(1, ::testing::_)).Times(1);

    // Act
    ASSERT_NO_THROW(pass::OpenGLPassUniformReader<Classic>::on(openglContext));

    // Assert
    // Optionally check if the uniforms are correctly added to the context
    ASSERT_EQ(openglContext->getUniforms().size(), 1);
    ASSERT_TRUE(openglContext->getUniforms().contains(mock::opengl::glFunctionMock::UNIFORM_NAME));
}

TEST_F(UniformReaderTests, ReadUniforms_NullContext)
{
    // Arrange

    // Act & Assert
    expectSpecificError([]()
                        { pass::OpenGLPassUniformReader<Classic>::on(nullptr); },
                        cenpy::common::exception::TraceableException<std::runtime_error>("ERROR::PASS::NON_OPENGL_CONTEXT"));
}

TEST_F(UniformReaderTests, ReadUniforms_InvalidPassID)
{
    // Arrange
    auto openglContext = std::make_shared<context::OpenGLPassContext>(); // No pipeline ID set

    // Act & Assert
    expectSpecificError([&openglContext]()
                        { pass::OpenGLPassUniformReader<Classic>::on(openglContext); },
                        cenpy::common::exception::TraceableException<std::runtime_error>("ERROR::PASS::INVALID_PROGRAM_ID"));
}

#endif // __mock_gl__
================================================================================
Contenu du fichier './tests/src/graphic/opengl/pipeline/component/pass/UserTests.cpp':
#ifdef __mock_gl__

#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <memory>
#include <opengl/glFunctionMock.hpp>
#include <graphic/opengl/context/MockUniformContext.hpp>
#include <graphic/opengl/pipeline/component/uniform/MockSetter.hpp>
#include <graphic/opengl/validator/Validator.hpp>
#include <graphic/opengl/context/PassContext.hpp>
#include <graphic/opengl/profile/Pass.hpp>
#include <graphic/opengl/pipeline/component/pass/User.hpp>
#include <TestUtils.hpp>

namespace context = cenpy::graphic::opengl::context;
namespace pass = cenpy::graphic::opengl::pipeline::component::pass;
namespace mock = cenpy::mock;
using cenpy::graphic::opengl::profile::Pass::Classic;
using cenpy::test::utils::expectSpecificError;

class UserTests : public ::testing::Test
{
protected:
    void TearDown() override
    {
        mock::opengl::glFunctionMock::reset();
    }
};

TEST_F(UserTests, UsePass_ValidContext)
{
    // Arrange
    auto openglContext = std::make_shared<context::OpenGLPassContext>();
    openglContext->setPassID(1); // Set a valid pipeline ID

    // Expect call to glUsePipeline with the correct pipeline ID
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glUseProgram_mock(1)).Times(1);

    // Act
    ASSERT_NO_THROW(pass::OpenGLPassUser<Classic>::on(openglContext));

    // Additional validations can be performed here if necessary
}

TEST_F(UserTests, UsePass_NullContext)
{
    // Arrange

    // Act & Assert
    expectSpecificError([]()
                        { pass::OpenGLPassUser<Classic>::on(nullptr); },
                        cenpy::common::exception::TraceableException<std::runtime_error>("ERROR::SHADER::NON_OPENGL_CONTEXT"));
}

#endif // __mock_gl__
================================================================================
Contenu du fichier './tests/src/graphic/opengl/pipeline/component/pipeline/ResetterTests.cpp':
#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <memory>
#include <graphic/opengl/context/PipelineContext.hpp>
#include <graphic/opengl/profile/Pipeline.hpp>
#include <graphic/opengl/pipeline/component/pipeline/Resetter.hpp>
#include <TestUtils.hpp>

using cenpy::graphic::opengl::context::OpenGLPipelineContext;
using cenpy::graphic::opengl::pipeline::component::pipeline::OpenGLPipelineResetter;
using cenpy::graphic::opengl::profile::Pipeline::Classic;
using cenpy::test::utils::expectSpecificError;

class ResetterTests : public ::testing::Test
{
};

TEST_F(ResetterTests, resetProgram_ValidContext)
{
    // Arrange
    auto context = std::make_shared<OpenGLPipelineContext>();
    context->setCurrentPass(42);

    // Act
    OpenGLPipelineResetter<Classic>::on(context);

    // Assert
    ASSERT_EQ(context->getCurrentPass(), -1);
}

TEST_F(ResetterTests, resetProgram_NullContext)
{
    // Arrange

    // Act & Assert
    expectSpecificError([]()
                        { OpenGLPipelineResetter<Classic>::on(nullptr); },
                        cenpy::common::exception::TraceableException<std::runtime_error>(std::format("ERROR::SHADER::NON_VALID_CONTEXT")));
}

================================================================================
Contenu du fichier './tests/src/graphic/opengl/pipeline/component/pipeline/UserTests.cpp':
#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <memory>
#include <graphic/pipeline/MockPass.hpp>

#include <graphic/opengl/validator/Validator.hpp>

#include <graphic/opengl/profile/Pipeline.hpp>
#include <graphic/opengl/pipeline/component/pipeline/User.hpp>
#include <graphic/Api.hpp>
#include <TestUtils.hpp>

namespace context = cenpy::graphic::opengl::context;
namespace api = cenpy::graphic::api;

using cenpy::graphic::opengl::pipeline::component::pipeline::OpenGLPipelineUser;
using cenpy::graphic::opengl::profile::Pipeline::Classic;
using cenpy::mock::graphic::pipeline::opengl::MockPass;
using cenpy::test::utils::expectSpecificError;

class UserTests : public ::testing::Test
{
};

TEST_F(UserTests, useProgram_ValidContext)
{
    // Arrange
    auto context = std::make_shared<context::OpenGLPipelineContext>();
    context->setCurrentPass(0);
    auto pass = std::make_shared<MockPass<api::OpenGL>>();
    context->addPass(pass);

    // Expect
    EXPECT_CALL(*pass, use()).Times(1);

    // Act
    OpenGLPipelineUser<Classic>::on(context);
}

TEST_F(UserTests, useProgram_NullContext)
{
    // Arrange
    // Act & Assert
    expectSpecificError([]()
                        { OpenGLPipelineUser<Classic>::on(nullptr); },
                        cenpy::common::exception::TraceableException<std::runtime_error>(std::format("ERROR::SHADER::NON_VALID_CONTEXT")));
}
================================================================================
Contenu du fichier './tests/src/graphic/opengl/pipeline/component/shader/FreerTests.cpp':
#ifdef __mock_gl__

#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <memory>
#include <opengl/glFunctionMock.hpp>
#include <graphic/MockApi.hpp>
#include <graphic/opengl/profile/Shader.hpp>
#include <graphic/opengl/context/ShaderContext.hpp>
#include <graphic/opengl/pipeline/component/shader/Freer.hpp>

namespace mock = cenpy::mock;
namespace api = cenpy::graphic::api;
namespace context = cenpy::graphic::opengl::context;
namespace shader = cenpy::graphic::opengl::pipeline::component::shader;
using cenpy::graphic::opengl::profile::Shader::Classic;

class FreerTests : public ::testing::Test
{
public:
    void TearDown() override
    {
        mock::opengl::glFunctionMock::reset();
    }
};

TEST_F(FreerTests, FreeShader_freeOnGPU)
{
    // Arrange
    auto shaderContext = std::make_shared<context::OpenGLShaderContext>();
    shaderContext->setShaderID(666);

    // Except calls
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glDeleteShader_mock(666)).Times(1);

    // Act
    ASSERT_NO_THROW(shader::OpenGLShaderFreer<Classic>::on(shaderContext));

    // Assert
}

TEST_F(FreerTests, FreeShader_setShaderIDToZero)
{
    // Arrange
    auto shaderContext = std::make_shared<context::OpenGLShaderContext>();
    shaderContext->setShaderID(666);

    // Act
    ASSERT_NO_THROW(shader::OpenGLShaderFreer<Classic>::on(shaderContext));

    // Assert
    ASSERT_EQ(shaderContext->getShaderID(), 0);
}

TEST_F(FreerTests, FreeShader_doNothing_whenShaderIDIsZero)
{
    // Arrange
    auto shaderContext = std::make_shared<context::OpenGLShaderContext>();
    shaderContext->setShaderID(0);

    // Except calls
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glDeleteShader_mock(::testing::_)).Times(0);

    // Act
    ASSERT_NO_THROW(shader::OpenGLShaderFreer<Classic>::on(shaderContext));

    // Assert
    ASSERT_EQ(shaderContext->getShaderID(), 0);
}

#endif // __mock_gl__
================================================================================
Contenu du fichier './tests/src/graphic/opengl/pipeline/component/shader/LoaderTests.cpp':
#ifdef __mock_gl__

#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <memory>
#include <opengl/glFunctionMock.hpp>
#include <graphic/MockApi.hpp>
#include <graphic/opengl/profile/Shader.hpp>
#include <graphic/opengl/context/ShaderContext.hpp>
#include <graphic/opengl/pipeline/component/shader/Loader.hpp>
#include <TestUtils.hpp>

namespace mock = cenpy::mock;
namespace api = cenpy::graphic::api;
namespace context = cenpy::graphic::opengl::context;
namespace shader = cenpy::graphic::opengl::pipeline::component::shader;
using cenpy::graphic::opengl::profile::Shader::Classic;
using cenpy::test::utils::expectSpecificError;

class LoaderTests : public ::testing::Test
{
public:
    void TearDown() override
    {
        mock::opengl::glFunctionMock::reset();
    }
};

TEST_F(LoaderTests, LoadShaderTest_callCreate)
{
    // Arrange
    auto shaderContext = std::make_shared<context::OpenGLShaderContext>();
    shaderContext->setShaderType(cenpy::graphic::context::ShaderType::VERTEX);

    // Except calls
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glCreateShader_mock(GL_VERTEX_SHADER)).Times(1);

    // Act
    ASSERT_NO_THROW(shader::OpenGLShaderLoader<Classic>::on(shaderContext));

    // Assert
}

TEST_F(LoaderTests, LoadShaderTest_callShaderSource)
{
    // Arrange
    auto shaderContext = std::make_shared<context::OpenGLShaderContext>();
    shaderContext->setShaderType(cenpy::graphic::context::ShaderType::VERTEX);

    // Except calls
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glShaderSource_mock(1, 1, ::testing::_, ::testing::_)).Times(1);

    // Act
    ASSERT_NO_THROW(shader::OpenGLShaderLoader<Classic>::on(shaderContext));

    // Assert
}

TEST_F(LoaderTests, LoadShaderTest_callCompile)
{
    // Arrange
    auto shaderContext = std::make_shared<context::OpenGLShaderContext>();
    shaderContext->setShaderType(cenpy::graphic::context::ShaderType::VERTEX);

    // Except calls
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glCompileShader_mock(1)).Times(1);

    // Act
    ASSERT_NO_THROW(shader::OpenGLShaderLoader<Classic>::on(shaderContext));

    // Assert
}

TEST_F(LoaderTests, LoadShaderTest_callGetIv)
{
    // Arrange
    auto shaderContext = std::make_shared<context::OpenGLShaderContext>();
    shaderContext->setShaderType(cenpy::graphic::context::ShaderType::VERTEX);

    // Except calls
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glGetShaderiv_mock(1, ::testing::_, ::testing::_)).Times(1);

    // Act
    ASSERT_NO_THROW(shader::OpenGLShaderLoader<Classic>::on(shaderContext));

    // Assert
}

TEST_F(LoaderTests, LoadShaderTest_setContextShaderId)
{
    // Arrange
    auto shaderContext = std::make_shared<context::OpenGLShaderContext>();
    shaderContext->setShaderType(cenpy::graphic::context::ShaderType::VERTEX);

    // Except calls

    // Act
    ASSERT_NO_THROW(shader::OpenGLShaderLoader<Classic>::on(shaderContext));

    // Assert
    ASSERT_EQ(shaderContext->getShaderID(), 1);
}

TEST_F(LoaderTests, LoadShaderFailureTest)
{
    // Arrange
    auto shaderContext = std::make_shared<context::OpenGLShaderContext>();
    shaderContext->setShaderType(cenpy::graphic::context::ShaderType::VERTEX);

    // Set mock behavior for shader compilation failure
    ON_CALL(*mock::opengl::glFunctionMock::instance(), glGetShaderiv_mock(1, GL_COMPILE_STATUS, ::testing::_))
        .WillByDefault(::testing::Invoke([](GLuint shader, GLenum pname, GLint *params)
                                         { *params = GL_FALSE; }));

    // Expect calls with failure behavior
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glGetShaderInfoLog_mock(1, ::testing::_, ::testing::_, ::testing::_)).Times(1);
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glDeleteShader_mock(1)).Times(1);

    // Act & Assert
    expectSpecificError([&shaderContext]()
                        { shader::OpenGLShaderLoader<Classic>::on(shaderContext); },
                        cenpy::common::exception::TraceableException<std::runtime_error>("ERROR::SHADER::COMPILATION_FAILED"));
}

#endif // __mock_gl__
================================================================================
Contenu du fichier './tests/src/graphic/opengl/pipeline/component/shader/ReaderTests.cpp':
#ifdef __mock_gl__

#include <gtest/gtest.h>
#include <memory>
#include <string>
#include <opengl/glFunctionMock.hpp>
#include <graphic/MockApi.hpp>
#include <graphic/opengl/profile/Shader.hpp>
#include <graphic/opengl/context/ShaderContext.hpp>
#include <graphic/opengl/pipeline/component/shader/Reader.hpp>

namespace context = cenpy::graphic::opengl::context;
namespace shader = cenpy::graphic::opengl::pipeline::component::shader;
namespace mock = cenpy::mock;
namespace api = cenpy::graphic::api;
using cenpy::graphic::opengl::profile::Shader::Classic;

class ReaderTests : public ::testing::Test
{
public:
    void TearDown() override
    {
        mock::opengl::glFunctionMock::reset();
    }
};

TEST_F(ReaderTests, ReadShaderTest)
{
    // Arrange
    auto context = std::make_shared<context::OpenGLShaderContext>();
    context->setShaderPath("test-datas/shaders/vertex/good/minimal.vert");
    std::string code = R"(#version 330 core

uniform int testUniform;
layout (location = 0) in vec3 aPos;

void main()
{
    gl_Position = vec4(aPos, 1.0) * float(testUniform);
}
)";

    // Act
    shader::OpenGLShaderReader<Classic>::on(context);

    // Assert
    ASSERT_EQ(context->getShaderCode(), code);
}

#endif // __mock_gl__
================================================================================
Contenu du fichier './tests/src/graphic/pipeline/AttributeTests.cpp':
#include <any>
#include <iostream>
#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <graphic/opengl/profile/Attribute.hpp>
#include <graphic/opengl/validator/Validator.hpp>
#include <graphic/pipeline/Attribute.hpp>
#include <graphic/opengl/context/MockAttributeContext.hpp>
#include <graphic/opengl/pipeline/component/attribute/MockSetter.hpp>
#include <graphic/opengl/pipeline/component/attribute/MockBinder.hpp>
#include <graphic/opengl/pipeline/component/attribute/MockUnbinder.hpp>
#include <graphic/MockApi.hpp>

namespace api = cenpy::mock::graphic::api;
namespace context = cenpy::graphic::opengl::context;
namespace pipeline = cenpy::graphic::pipeline;
namespace mock = cenpy::mock::graphic::opengl::pipeline::component::attribute;

using cenpy::graphic::opengl::profile::Attribute::Classic;

class AttributeTest : public ::testing::Test
{
public:
    void TearDown() override
    {
    }
};

TEST_F(AttributeTest, BindTest)
{
    // Arrange
    auto attributeContext = std::make_shared<api::MockOpenGL::AttributeContext>();

    pipeline::Attribute<api::MockOpenGL, Classic> attribute(attributeContext);

    // Expect calls
    EXPECT_CALL(*mock::MockBinder<Classic>::instance(), mockOn(::testing::_)).Times(1);

    // Act
    ASSERT_NO_THROW(attribute.bind());
}

TEST_F(AttributeTest, UnbindTest)
{
    // Arrange
    auto attributeContext = std::make_shared<api::MockOpenGL::AttributeContext>();

    pipeline::Attribute<api::MockOpenGL, Classic> attribute(attributeContext);

    // Expect calls
    EXPECT_CALL(*mock::MockUnbinder<Classic>::instance(), mockOn(::testing::_)).Times(1);

    // Act
    ASSERT_NO_THROW(attribute.unbind());
}

TEST_F(AttributeTest, SetTest)
{
    // Arrange
    auto attributeContext = std::make_shared<api::MockOpenGL::AttributeContext>();

    pipeline::Attribute<api::MockOpenGL, Classic> attribute(attributeContext);

    // Expect calls
    EXPECT_CALL(*mock::MockSetter<int>::instance(), mockOn(::testing::_)).Times(1);

    // Act
    ASSERT_NO_THROW(attribute.set(std::make_shared<int>(1)));
}

TEST_F(AttributeTest, GetContextTest)
{
    // Arrange
    auto attributeContext = std::make_shared<api::MockOpenGL::AttributeContext>();

    pipeline::Attribute<api::MockOpenGL, Classic> attribute(attributeContext);

    // Act
    ASSERT_EQ(attributeContext, attribute.getContext());
}
================================================================================
Contenu du fichier './tests/src/graphic/pipeline/PassTests.cpp':
#ifdef __mock_gl__
#include <string>
#include <memory>
#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <opengl/glFunctionMock.hpp>
#include <graphic/pipeline/Pass.hpp>

#include <graphic/opengl/profile/Pass.hpp>
#include <graphic/opengl/validator/Validator.hpp>

#include <graphic/opengl/pipeline/component/pass/MockShaderAttacher.hpp>
#include <graphic/opengl/pipeline/component/pass/MockUniformReader.hpp>
#include <graphic/opengl/pipeline/component/pass/MockAttributeReader.hpp>
#include <graphic/opengl/pipeline/component/pass/MockUser.hpp>
#include <graphic/opengl/pipeline/component/pass/MockFreer.hpp>
#include <graphic/opengl/pipeline/component/pass/MockLoader.hpp>
#include <graphic/pipeline/MockShader.hpp>
#include <graphic/pipeline/MockUniform.hpp>
#include <graphic/pipeline/MockAttribute.hpp>
#include <graphic/opengl/context/MockPassContext.hpp>
#include <graphic/MockApi.hpp>
#include <TestUtils.hpp>

namespace api = cenpy::mock::graphic::api;
namespace context = cenpy::graphic::context;
namespace pipeline = cenpy::graphic::pipeline;
namespace mock = cenpy::mock;

using mock::graphic::opengl::pipeline::component::pass::MockAttributeReader;
using mock::graphic::opengl::pipeline::component::pass::MockFreer;
using mock::graphic::opengl::pipeline::component::pass::MockLoader;
using mock::graphic::opengl::pipeline::component::pass::MockShaderAttacher;
using mock::graphic::opengl::pipeline::component::pass::MockUniformReader;
using mock::graphic::opengl::pipeline::component::pass::MockUser;
using mock::graphic::pipeline::MockAttribute;
using mock::graphic::pipeline::MockShader;
using mock::graphic::pipeline::MockUniform;

using cenpy::graphic::opengl::profile::Pass::Classic;
using cenpy::test::utils::expectSpecificError;
class PassTest : public ::testing::Test
{
public:
    void TearDown() override
    {
        mock::opengl::glFunctionMock::reset();
        MockFreer<Classic>::reset();
        MockLoader<Classic>::reset();
        MockShaderAttacher<Classic>::reset();
        MockUniformReader<Classic>::reset();
        MockUser<Classic>::reset();
        MockAttributeReader<Classic>::reset();
    }
};

TEST_F(PassTest, LoadPass)
{
    // Arrange
    auto mockShader = std::make_shared<MockShader<api::MockOpenGL>>();
    pipeline::Pass<api::MockOpenGL, Classic> pass({mockShader});

    // Expect calls
    EXPECT_CALL(*api::MockOpenGL::PassContext::Loader<Classic>::instance(), mockOn(::testing::_)).Times(1);
    EXPECT_CALL(*api::MockOpenGL::PassContext::UniformReader<Classic>::instance(), mockOn(::testing::_)).Times(1);

    // Act
    ASSERT_NO_THROW(pass.load());
}

TEST_F(PassTest, WithUniforms)
{
    // Arrange
    auto mockShader = std::make_shared<MockShader<api::MockOpenGL>>();
    auto mockUniform = std::make_shared<MockUniform<api::MockOpenGL>>();
    pipeline::Pass<api::MockOpenGL, Classic> pass({mockShader});

    // Expect calls
    EXPECT_CALL(*api::MockOpenGL::PassContext::UniformReader<Classic>::instance(), mockOn(::testing::_)).WillOnce(::testing::Invoke([&](std::shared_ptr<context::PassContext<api::MockOpenGL>> context)
                                                                                                                                    { context->addUniform("test", mockUniform); }));
    EXPECT_CALL(*mock::opengl::glFunctionMock::instance(), glUniform1f_mock(::testing::_, ::testing::_)).Times(1);

    pass.load();

    // Act
    ASSERT_NO_THROW(pass.withUniform("test", 1.0f));
}

TEST_F(PassTest, WithUniforms_NoUniform)
{
    // Arrange
    auto mockShader = std::make_shared<MockShader<api::MockOpenGL>>();
    auto mockUniform = std::make_shared<MockUniform<api::MockOpenGL>>();
    pipeline::Pass<api::MockOpenGL, Classic> pass({mockShader});
    pass.load();

    // Act
    expectSpecificError([&pass]()
                        { pass.withUniform("test", 1.0f); },
                        cenpy::common::exception::TraceableException<std::runtime_error>("ERROR::SHADER::UNIFORM_NOT_FOUND"));
}

TEST_F(PassTest, UsePass)
{
    // Arrange
    pipeline::Pass<api::MockOpenGL, Classic> pass({});

    // Expect calls
    EXPECT_CALL(*api::MockOpenGL::PassContext::User<Classic>::instance(), mockOn(::testing::_)).Times(1);

    // Act
    ASSERT_NO_THROW(pass.use());
}

TEST_F(PassTest, FreePass)
{
    // Arrange
    pipeline::Pass<api::MockOpenGL, Classic> pass({});

    // Expect calls
    EXPECT_CALL(*api::MockOpenGL::PassContext::Freer<Classic>::instance(), mockOn(::testing::_)).Times(2);

    // Act
    ASSERT_NO_THROW(pass.free());
}

TEST_F(PassTest, GetUniforms)
{
    // Arrange
    auto mockShader = std::make_shared<MockShader<api::MockOpenGL>>();
    auto mockUniform = std::make_shared<MockUniform<api::MockOpenGL>>();
    pipeline::Pass<api::MockOpenGL, Classic> pass({mockShader});

    // Expect calls
    EXPECT_CALL(*api::MockOpenGL::PassContext::UniformReader<Classic>::instance(), mockOn(::testing::_)).WillOnce(::testing::Invoke([&](std::shared_ptr<context::PassContext<api::MockOpenGL>> context)
                                                                                                                                    { context->addUniform("test", mockUniform); }));

    pass.load();
    // Act
    ASSERT_EQ(pass.getUniforms().size(), 1);
    ASSERT_TRUE(pass.getUniforms().contains("test"));
}

TEST_F(PassTest, GetAttributes)
{
    // Arrange
    auto mockShader = std::make_shared<MockShader<api::MockOpenGL>>();
    auto mockAttribute = std::make_shared<MockAttribute<api::MockOpenGL>>();
    pipeline::Pass<api::MockOpenGL, Classic> pass({mockShader});

    // Expect calls
    EXPECT_CALL(*api::MockOpenGL::PassContext::AttributeReader<Classic>::instance(), mockOn(::testing::_)).WillOnce(::testing::Invoke([&](std::shared_ptr<context::PassContext<api::MockOpenGL>> context)
                                                                                                                                      { context->addAttribute("test", mockAttribute); }));

    pass.load();
    // Act
    ASSERT_EQ(pass.getAttributes().size(), 1);
    ASSERT_TRUE(pass.getAttributes().contains("test"));
}

TEST_F(PassTest, GetShader)
{
    // Arrange
    auto mockShader = std::make_shared<MockShader<api::MockOpenGL>>();
    pipeline::Pass<api::MockOpenGL, Classic> pass({mockShader});

    // Act
    ASSERT_EQ(pass.getShaders()[0], mockShader);
}

TEST_F(PassTest, GetContext)
{
    // Arrange
    auto mockShader = std::make_shared<MockShader<api::MockOpenGL>>();
    pipeline::Pass<api::MockOpenGL, Classic> pass({mockShader});

    // Act
    ASSERT_NE(pass.getContext(), nullptr);
}

#endif //::testing::__mock_gl__
================================================================================
Contenu du fichier './tests/src/graphic/pipeline/PipelineTests.cpp':

#include <string>
#include <memory>
#include <gtest/gtest.h>
#include <gmock/gmock.h>

#include <graphic/opengl/profile/Pipeline.hpp>
#include <graphic/opengl/validator/Validator.hpp>

#include <graphic/pipeline/Pipeline.hpp>
#include <graphic/pipeline/MockPass.hpp>
#include <graphic/opengl/context/MockPipelineContext.hpp>
#include <graphic/opengl/pipeline/component/pipeline/MockUser.hpp>
#include <graphic/opengl/pipeline/component/pipeline/MockResetter.hpp>
#include <graphic/MockApi.hpp>
#include <TestUtils.hpp>

namespace api = cenpy::mock::graphic::api;
namespace context = cenpy::graphic::context;
namespace pipeline = cenpy::graphic::pipeline;
namespace mock = cenpy::mock;

using mock::graphic::opengl::pipeline::component::pipeline::MockResetter;
using mock::graphic::opengl::pipeline::component::pipeline::MockUser;
using mock::graphic::pipeline::opengl::MockPass;

using cenpy::graphic::opengl::profile::Pipeline::Classic;
using cenpy::test::utils::expectSpecificError;

class PipelineTest : public ::testing::Test
{
};

TEST_F(PipelineTest, UseTest)
{
    // Arrange
    auto mockPass1 = std::make_shared<MockPass<api::MockOpenGL>>();
    auto mockPass2 = std::make_shared<MockPass<api::MockOpenGL>>();
    pipeline::Pipeline<api::MockOpenGL, Classic> pipeline({mockPass1, mockPass2});

    // Expect calls
    EXPECT_CALL(*MockUser<Classic>::instance(), mockOn(::testing::_)).Times(1);

    // Act
    pipeline.use(0); // Using first pass
}

TEST_F(PipelineTest, IteratePassesTest)
{
    // Arrange
    auto mockPass1 = std::make_shared<MockPass<api::MockOpenGL>>();
    auto mockPass2 = std::make_shared<MockPass<api::MockOpenGL>>();
    pipeline::Pipeline<api::MockOpenGL, Classic> pipeline({mockPass1, mockPass2});

    // Expect calls
    EXPECT_CALL(*MockUser<Classic>::instance(), mockOn(::testing::_)).Times(2);

    // Act
    while (pipeline.hasNext())
    {
        pipeline.useNext();
    }
}

TEST_F(PipelineTest, ResetPipelineTest)
{
    // Arrange
    pipeline::Pipeline<api::MockOpenGL, Classic> pipeline({nullptr});

    // Expect calls
    EXPECT_CALL(*MockResetter<Classic>::instance(), mockOn(::testing::_)).Times(1);

    // Act
    pipeline.reset();
}

TEST_F(PipelineTest, GetContext)
{
    // Arrange
    auto mockPass1 = std::make_shared<MockPass<api::MockOpenGL>>();
    auto mockPass2 = std::make_shared<MockPass<api::MockOpenGL>>();
    pipeline::Pipeline<api::MockOpenGL, Classic> pipeline({mockPass1, mockPass2});

    // Act
    auto context = pipeline.getContext();

    // Assert
    ASSERT_NE(context, nullptr);
}
================================================================================
Contenu du fichier './tests/src/graphic/pipeline/ShaderTests.cpp':
#ifdef __mock_gl__
#include <string>
#include <memory>
#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <opengl/glFunctionMock.hpp>
#include <graphic/pipeline/Shader.hpp>

#include <graphic/opengl/profile/Shader.hpp>
#include <graphic/opengl/validator/Validator.hpp>

#include <graphic/opengl/pipeline/component/shader/MockReader.hpp>
#include <graphic/opengl/pipeline/component/shader/MockLoader.hpp>
#include <graphic/opengl/pipeline/component/shader/MockFreer.hpp>
#include <graphic/opengl/context/MockShaderContext.hpp>
#include <graphic/MockApi.hpp>

namespace api = cenpy::mock::graphic::api;
namespace context = cenpy::graphic::context;
namespace pipeline = cenpy::graphic::pipeline;
namespace mock = cenpy::mock;

using mock::graphic::opengl::pipeline::component::shader::MockFreer;
using mock::graphic::opengl::pipeline::component::shader::MockLoader;
using mock::graphic::opengl::pipeline::component::shader::MockReader;

using cenpy::graphic::opengl::profile::Shader::Classic;

class ShaderTest : public ::testing::Test
{
public:
    void TearDown() override
    {
        mock::opengl::glFunctionMock::reset();
        MockFreer<Classic>::reset();
        MockLoader<Classic>::reset();
        MockReader<Classic>::reset();
    }
};

TEST_F(ShaderTest, CreateShader)
{
    // Arrange
    pipeline::Shader<api::MockOpenGL, Classic> shader("test-datas/shaders/vertex/good/minimal.vert", context::ShaderType::VERTEX);

    // Expect calls
    std::string code("");
    ON_CALL(*shader.getContext(), getShaderCode()).WillByDefault(::testing::ReturnRef(code));
    EXPECT_CALL(*MockReader<Classic>::instance(), mockOn(::testing::_)).Times(1);
    EXPECT_CALL(*MockLoader<Classic>::instance(), mockOn(::testing::_)).Times(1);
    // Act
    ASSERT_NO_THROW(shader.load());
}

TEST_F(ShaderTest, CreateShader_codeAlreadyRead)
{
    // Arrange
    pipeline::Shader<api::MockOpenGL, Classic> shader("test-datas/shaders/vertex/good/minimal.vert", context::ShaderType::VERTEX);

    // Expect calls
    std::string code("test");
    ON_CALL(*shader.getContext(), getShaderCode()).WillByDefault(::testing::ReturnRef(code));
    EXPECT_CALL(*MockReader<Classic>::instance(), mockOn(::testing::_)).Times(0);
    EXPECT_CALL(*MockLoader<Classic>::instance(), mockOn(::testing::_)).Times(1);
    // Act
    ASSERT_NO_THROW(shader.load());
}

TEST_F(ShaderTest, Free)
{
    // Arrange
    pipeline::Shader<api::MockOpenGL, Classic> shader("test-datas/shaders/vertex/good/minimal.vert", context::ShaderType::VERTEX);

    // Expect calls
    EXPECT_CALL(*MockFreer<Classic>::instance(), mockOn(::testing::_)).Times(2);

    ASSERT_NO_THROW(shader.free());
}

TEST_F(ShaderTest, DeleteMustFree)
{
    // Arrange
    auto shader = new pipeline::Shader<api::MockOpenGL, Classic>("test-datas/shaders/vertex/good/minimal.vert", context::ShaderType::VERTEX);

    // Expect calls
    EXPECT_CALL(*MockFreer<Classic>::instance(), mockOn(::testing::_)).Times(1);

    ASSERT_NO_THROW(delete shader);
}

#endif //::testing::__mock_gl__
================================================================================
Contenu du fichier './tests/src/graphic/pipeline/UniformTests.cpp':
#ifdef __mock_gl__
#include <any>
#include <iostream>
#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <graphic/Api.hpp>
#include <opengl/glFunctionMock.hpp>
#include <graphic/opengl/pipeline/component/uniform/Setter.hpp>
#include <graphic/opengl/validator/Validator.hpp>
#include <graphic/pipeline/Uniform.hpp>
#include <graphic/opengl/context/UniformContext.hpp>

namespace api = cenpy::graphic::api;
namespace context = cenpy::graphic::opengl::context;
namespace pipeline = cenpy::graphic::pipeline;
namespace mock = cenpy::mock::opengl;

class UniformTest : public ::testing::Test
{
public:
    void TearDown() override
    {
        mock::glFunctionMock::reset();
    }
};

TEST_F(UniformTest, SetFloatUniform)
{
    // Arrange
    GLuint location = 42;
    GLfloat value = 3.14f;
    auto uniformContext = std::make_shared<api::OpenGL::UniformContext>();
    uniformContext->setUniformID(location);
    uniformContext->setValue(1.0f);

    pipeline::Uniform<api::OpenGL> uniform(uniformContext);

    // Expected call
    EXPECT_CALL(*mock::glFunctionMock::instance(), glUniform1f_mock(location, value))
        .Times(1);

    // Act
    ASSERT_NO_THROW(uniform.set(value));
}

TEST_F(UniformTest, SetDoubleUniform)
{
    // Arrange
    GLuint location = 42;
    GLdouble value = 3.14;
    auto uniformContext = std::make_shared<api::OpenGL::UniformContext>();
    uniformContext->setUniformID(location);
    uniformContext->setValue(1.0);

    pipeline::Uniform<api::OpenGL> uniform(uniformContext);

    // Expected call
    EXPECT_CALL(*mock::glFunctionMock::instance(), glUniform1d_mock(location, value))
        .Times(1);

    // Act
    ASSERT_NO_THROW(uniform.set(value));
}

TEST_F(UniformTest, SetIntUniform)
{
    // Arrange
    GLuint location = 42;
    GLint value = 42;
    auto uniformContext = std::make_shared<api::OpenGL::UniformContext>();
    uniformContext->setUniformID(location);
    uniformContext->setValue(1);

    pipeline::Uniform<api::OpenGL> uniform(uniformContext);

    // Expected call
    EXPECT_CALL(*mock::glFunctionMock::instance(), glUniform1i_mock(location, value))
        .Times(1);

    // Act
    ASSERT_NO_THROW(uniform.set(value));
}

TEST_F(UniformTest, SetUIntUniform)
{
    // Arrange
    GLuint location = 42;
    GLuint value = 42;

    auto uniformContext = std::make_shared<api::OpenGL::UniformContext>();
    uniformContext->setUniformID(location);
    uniformContext->setValue((GLuint)1);

    pipeline::Uniform<api::OpenGL> uniform(uniformContext);

    // Expected call
    EXPECT_CALL(*mock::glFunctionMock::instance(), glUniform1ui_mock(location, value))
        .Times(1);

    // Act
    ASSERT_NO_THROW(uniform.set(value));
}

TEST_F(UniformTest, SetVec2Uniform)
{
    // Arrange
    GLuint location = 42;
    glm::vec2 value(3.14f, 2.71f);
    auto uniformContext = std::make_shared<api::OpenGL::UniformContext>();
    uniformContext->setUniformID(location);
    uniformContext->setValue(glm::vec2(1.0f, 1.0f));

    pipeline::Uniform<api::OpenGL> uniform(uniformContext);

    // Expected call
    EXPECT_CALL(*mock::glFunctionMock::instance(), glUniform2fv_mock(location, 0, ::testing::_))
        .Times(1);

    // Act
    ASSERT_NO_THROW(uniform.set(value));
}

TEST_F(UniformTest, SetVec3Uniform)
{
    // Arrange
    GLuint location = 42;
    glm::vec3 value(3.14f, 2.71f, 1.41f);
    auto uniformContext = std::make_shared<api::OpenGL::UniformContext>();
    uniformContext->setUniformID(location);
    uniformContext->setValue(glm::vec3(1.0f, 1.0f, 1.0f));

    pipeline::Uniform<api::OpenGL> uniform(uniformContext);

    // Expected call
    EXPECT_CALL(*mock::glFunctionMock::instance(), glUniform3fv_mock(location, 0, ::testing::_))
        .Times(1);

    // Act
    ASSERT_NO_THROW(uniform.set(value));
}

TEST_F(UniformTest, SetVec4Uniform)
{
    // Arrange
    GLuint location = 42;
    glm::vec4 value(3.14f, 2.71f, 1.41f, 1.61f);
    auto uniformContext = std::make_shared<api::OpenGL::UniformContext>();
    uniformContext->setUniformID(location);
    uniformContext->setValue(glm::vec4(1.0f, 1.0f, 1.0f, 1.0f));

    pipeline::Uniform<api::OpenGL> uniform(uniformContext);

    // Expected call
    EXPECT_CALL(*mock::glFunctionMock::instance(), glUniform4fv_mock(location, 0, ::testing::_))
        .Times(1);

    // Act
    ASSERT_NO_THROW(uniform.set(value));
}

TEST_F(UniformTest, SetMat2Uniform)
{
    // Arrange
    GLuint location = 42;
    glm::mat2 value(3.14f, 2.71f, 1.41f, 1.61f);
    auto uniformContext = std::make_shared<api::OpenGL::UniformContext>();
    uniformContext->setUniformID(location);
    uniformContext->setValue(glm::mat2(1.0f, 1.0f, 1.0f, 1.0f));

    pipeline::Uniform<api::OpenGL> uniform(uniformContext);

    // Expected call
    EXPECT_CALL(*mock::glFunctionMock::instance(), glUniformMatrix2fv_mock(location, 0, GL_FALSE, ::testing::_))
        .Times(1);

    // Act
    ASSERT_NO_THROW(uniform.set(value));
}

TEST_F(UniformTest, SetMat3Uniform)
{
    // Arrange
    GLuint location = 42;
    glm::mat3 value(3.14f, 2.71f, 1.41f, 1.61f, 2.71f, 1.41f, 1.61f, 2.71f, 1.41f);
    auto uniformContext = std::make_shared<api::OpenGL::UniformContext>();
    uniformContext->setUniformID(location);
    uniformContext->setValue(glm::mat3(1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f,
                                       1.0f, 1.0f, 1.0f));

    pipeline::Uniform<api::OpenGL> uniform(uniformContext);

    // Expected call
    EXPECT_CALL(*mock::glFunctionMock::instance(), glUniformMatrix3fv_mock(location, 0, GL_FALSE, ::testing::_))
        .Times(1);

    // Act
    ASSERT_NO_THROW(uniform.set(value));
}

TEST_F(UniformTest, SetMat4Uniform)
{
    // Arrange
    GLuint location = 42;
    glm::mat4 value(3.14f, 2.71f, 1.41f, 1.61f, 2.71f, 1.41f, 1.61f, 2.71f, 1.41f, 1.61f, 2.71f, 1.41f, 1.61f, 2.71f, 1.41f, 1.61f);
    auto uniformContext = std::make_shared<api::OpenGL::UniformContext>();
    uniformContext->setUniformID(location);
    uniformContext->setValue(glm::mat4(1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f,
                                       1.0f, 1.0f, 1.0f, 1.0f, 1.0, 1.0f, 1.0f, 1.0f));

    pipeline::Uniform<api::OpenGL> uniform(uniformContext);

    // Expected call
    EXPECT_CALL(*mock::glFunctionMock::instance(), glUniformMatrix4fv_mock(location, 0, GL_FALSE, ::testing::_))
        .Times(1);

    // Act
    ASSERT_NO_THROW(uniform.set(value));
}

#endif // __mock_gl__

================================================================================
